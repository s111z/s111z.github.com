{"themeConfig":{"themeName":"example","postPageSize":1,"archivesPageSize":50,"siteName":"Gridea","siteDescription":"温故而知新","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":false,"domain":"https://s111z.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"content":"Treasure Chest 题目大意：玩家初始在位置0，箱子在位置x，钥匙在位置y，玩家向左（右）移动一格花费1s，其他操作不花费时间，同时玩家只能抱着箱子行走t秒，当玩家、箱子、钥匙在同一点时，解锁成功，要求玩家最少需要多少秒。 思路：这里只用考虑箱子和钥匙的相对位置即可。 如果钥匙离玩家更近，那么直接走到箱子所花费的时间就是要求的时间； 如果箱子离玩家近，那么说明拿完钥匙要折返，于是抱着箱子往前走一点，就可以使折返时间更小。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); if(a&gt;=b) printf(&quot;%d\\n&quot;,a); else//box近 { int ti=b+max(b-a-c,0); printf(&quot;%d\\n&quot;,ti); } } } Points and Minimum Distance 题目大意：给一个有2*n个元素的数组，我们要将这些数凑成n对，每一对数表示一个坐标，我们要找一条路径保证每个点至少经过一次，两点之间的距离为曼哈顿距离，问这条路径长度的最小值是多少。 思路：相当于就将差值小的放一块儿减，那么就将数组排序，然后前一半全部用来作为横坐标，后一半用来做为纵坐标。横坐标内部相减累计，纵坐标同理。 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int a[200]; signed main() { int t; scanf(&quot;%lld&quot;,&amp;t); while(t--) { int n; scanf(&quot;%lld&quot;,&amp;n); int len=2*n; for(int i=1;i&lt;=len;i++) scanf(&quot;%lld&quot;,&amp;a[i]); sort(a+1,a+len+1); int sum=0; for(int i=1;i&lt;n;i++) sum += a[i+1]-a[i]; for(int i=n+1;i&lt;len;i++) sum += a[i+1]-a[i]; printf(&quot;%lld\\n&quot;,sum); for(int i=1;i&lt;=n;i++) { printf(&quot;%d %d\\n&quot;,a[i],a[i+n]); } } } Torn Lucky Ticket 题目大意：给n个字串，每个字串的每一位都是1-9的某个数字，我们要将任意两串拼接起来，如果拼接后的字串满足，长度为偶数，同时前半段的数位和等于后半段的数位和，那么这就是个合法的拼接。问有多少个合法拼接。（注意si+sj != sj+si,同时i==j是合法的） 思路：这道题的实现思路很巧妙，我们首先分析题目，可以发现拼接后，从中间切并不一定保证前半段或者后半段一定是原来的字串。所以对每个字串可能将被从任意地方切开，那么我们就循环这个字串，记录从它每个位置切需要补一个什么样的字串上去。这里我们通过数位和与长度这两个属性来确定字串。记录结束之后，我们遍历原字串数组，累计这个字串的属性被标记了几次，那么就相当于它可以补给几个其他字串，累计一下就好 ，由于si+sj != sj+si，所以不用考虑会重复记录。另外还有一点要考虑，这个字串可以补在后面，也可以补在前面，当这字串补在后面的时候，属性是正值，但当它补在前面的时候，实际上记录它的那个mp中记录的属性应该是负数。 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int sum[200010]; char s[200010][10]; signed main() { map&lt;pair&lt;int,int&gt;,int&gt;mp; int n; scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%s&quot;,s[i]); int l=strlen(s[i]); int ssum=0; for(int j=0;j&lt;l;j++) ssum += s[i][j]-'0'; for(int j=0;j&lt;l;j++) { sum[i] += s[i][j]-'0'; mp[{2*sum[i]-ssum,2*(j+1)-l}]++; } } int ans=0; for(int i=1;i&lt;=n;i++) { int l=strlen(s[i]); ans += mp[{sum[i],l}]+mp[{-sum[i],-l}]; //我们计算答案时就是要去找每个字串可以跟哪些字串匹配，那我们不如预处理每个字串从不同位置划分需要补的部分，那么这样的话每个字串的性质如果符合另一个字串某一划分的补就可将两者拼接 } printf(&quot;%lld&quot;,ans); } XOR Construction 题目大意：给定一个a[]={a1,a2,...,a(n-1)},a[1]=b[1]^b[2],a[2]= b[2]^b[3],... b[]中的数在0~n-1，同时每个数都只出现一次， 求b[] 思路:a[1]=b[1]b[2]=&gt;b[2]=a[1]b[1],相当于，我们只要确定一个数就能将整个b[]都推出来（先不考虑是否合法），那么我们就将0放在第一位，推出整个b[],这时候有个新的问题，b[]是有范围的，它要在0~n-1之间，我们就需要对已经得到的数组进行处理，这里的处理方法很妙，我们推导可发现，对于0-x，二进制的每一位上，对于整个范围来说，都是0的个数&gt;=1的个数，那么我们只要在1的个数大于0的个数的时候将每个数的这一位都异或上1就可以实现0的个数&gt;=1的个数。详见 。 #include &lt;stdio.h&gt; int a[200005],n; int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); a[i]^=a[i-1]; }//这里相当于将b第一个值定为0，然后求b[] //将b控制在0~n-1 for(int j=0;1&lt;&lt;j &lt; n;j++) { int d=0; for(int i=0;i&lt;n;i++)//访问每一个数的第j位 d+=(a[i]&amp;1&lt;&lt;j)==0? 1:-1;//如果a[i]的第j位是0就加1，否则减1， //先算1&lt;&lt;j，那就是取a[i]的第j位 if(d&lt;0)//如果1比0多，这里就是要保证所有相同位中，总的1要比0少 for(int i=0;i&lt;n;i++) a[i] ^= 1&lt;&lt;j;//每个a[i]的第j位都异或上1 //相邻两个数的相对01都不变，所以异或还是可以得到我们想要的a[],让0比1多就可以限制b的范围？ } for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,a[i]); return 0; } ","tags":[],"title":"Educational Codeforces Round 157 (Rated for Div. 2)补题","feature":"","link":"https://s111z.github.io/post/educational-codeforces-round-157-rated-for-div-2bu-ti/","stats":{"text":"7 min read","time":409000,"words":1589,"minutes":7},"date":"2023-11-04 14:36:44","dateFormat":"2023-11-04"},{"content":"将一个数组中的数映射到0~n-1,同时保证相邻两个数的异或和不变 我们以7为例 000 001 010 011 100 101 110 111 我们可以发现，不管从什么位置截断，前面的数都是0的个数&gt;=1的个数，那么我们统计数组中所有数每一位上1和0的个数，如果1的个数大于0的个数，那么我们就将数组中每个数的这一位都异或1. 应用： 388535 (Easy Version) XOR Construction ","tags":[],"title":"异或-映射","feature":"","link":"https://s111z.github.io/post/yi-huo-ying-she/","stats":{"text":"1 min read","time":30000,"words":132,"minutes":1},"date":"2023-11-04 14:02:53","dateFormat":"2023-11-04"},{"content":"当 G′ 是图 G 的子图，且 G′ 是关于 V′ 的完全图时，子图 G' 为图 G 的团；当 G' 是团，且不是其他团的子集时，G' 为图 G 的极大团；当 G' 是极大团时，且点数最多，G' 为图 G 最大团 完全图：图中n个点，任意两点之间都有边。 极大团：实际就是一个独立的块 最大团：点数最多的极大团 最大独立集：图中的一个点集，点与点之间互不相邻(去除图中团后的点集) 最大独立集数=补图的最大团 当用数目最少的团覆盖整张图的时候，称为最小团覆盖 我们从最小团覆盖所选的这些团中每个团选一点，即可得到独立集，而显然最大独立集的中的点数 ","tags":[],"title":"最大团","feature":"","link":"https://s111z.github.io/post/zui-da-tuan/","stats":{"text":"1 min read","time":45000,"words":215,"minutes":1},"date":"2023-11-03 15:20:20","dateFormat":"2023-11-03"},{"content":"LCA即最近公共祖先。 给定一棵树及它的根节点，每次询问给出x,y两个点，我们要求x和y的最近公共祖先（公共祖先：F既是x的祖先也是y的祖先，那么F就是公共祖先，我们要求距离两者最近的那个公共祖先，即为LCA(x,y)） LCA的性质： 1.在所有的公共祖先中距离x和y都是最近的， 2.x,y之间的最短路径经过LCA(x,y)（这个后面点分树会用上） 3.x,y本身也可以是自己的公共祖先(当一个点是另一个点的子节点是成立) 暴力（虽然会超时，但却是后面两种思维的起点） 思路：我们先根据根节点定出x,y的层级，如果x的层级比y深（y的层级比x深同理），我们让x一层一层往上，当与y同级时，如果x没和y重合，那么就是x和y一起往上找，直到x和y重合为止。 有多个询问，如果对每个询问都这么处理，显而易见，会超时。那么就需要进行优化。 倍增法： 这里是对找层级进行优化，在暴力算法中，层级是一层一层往上找的，我们可以引入二进制优化，即每次上跳2i,很容易证明任何一个正整数都可以被拆成若干个2i（i为非负整数）相加，那么我们就可以这么跳。只需要在建立层级的时候，将每个点上跳2^i到哪个点记录一下即可。这里涉及到一个递推： f[x][i]表示x上跳2^i到的点，递推关系为： f[x][i]=f[f[x][i-1]][i-1] 解释：x上跳2i次方等价于x上跳到2(i-1)位置再上跳2(i-1),2(i-1)+2(i-1)=2i; 递推公式的意义就是方便我们的计算，因为边缘状态比较好确定，剩下的直接递推就可以得到。 除了对上跳进行优化以外，别的地方都不变，也是x先上跳到与y相同层级，然后再一起上跳。 #include&lt;bits/stdc++.h&gt; using namespace std; cont int N=500005; int h[N],e[2*N],ne[2*N],idx; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int d[N]; void dfs(int u,int fa) { d[u]=d[fa]+1; f[u][0]=fa;//上跳2^0=1,即跳到父节点 for(int i=1;u-(1&lt;&lt;i)&lt;=d[u];i++) f[u][i]=f[f[u][i-1]][i-1]; //这里的判断条件要注意一下，不能跳出去了 //f[x][i]只是用来记录x上跳2^i后会落在哪里，实际跳的距离还是2^i for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(j!=fa) { dfs(j,u); } } } int LCA(int x,int y) { if(d[x]&lt;d[y]) swap(x,y); for(int i=20;i&gt;=0;i--) { if(d[x] - (1&lt;&lt;i)&gt;=d[y]) x=f[x][i]; } if(x==y) return x; for(int i=20;i&gt;=0;i--) { if(f[x][i]!=f[y][i]) //比公共祖先深度浅的祖先对两者来说都是相同的，所以这里从最大的开始看，如果不相等，就证明还没有到最近公共祖先，自然可以上跳 x=f[x][i],y=f[y][i]; } return f[x][0]; } int main() { int n,m,root; scanf(&quot;%d%d&quot;,&amp;n,&amp;m,&amp;root); for(int i=1;i&lt;n;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b),add(b,a); } dfs(root,root); while(m--) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d&quot;,LCA(a,b)); } } Tarjin 上面一种算法是对每个询问单独处理，如果我们可以像点分治中一样统一处理所有的询问，自然会更快。 倍增法是通过上跳来找，那我们换个思路，在建树的过程中就向下找，访问到y的时候，如果x已经被访问过，那么就有两种情况，如下图： 上图中第一种情况，x是y的祖先，我们dfs()传入两个参数，当前节点u和父节点fa，那么我们在访问y的时候，发现已经访问过x了，就只用去找y的祖先，就会找到x，具体实现我们后面结合代码来说 第二种情况，也是去找y的祖先，可以找到u，具体实现结合代码来说。 void dfs(int u,int fa) { f[u]=u; for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(j!=fa) { dfs(j,u); f[j]=u; } } //因为是一层一层往里面搜的，当前层搜的u的父节点就是本身，对于第一种情况往上找一定会找到x； //对于第二种情况，访问x层时，实际上还没有结束u层，那么f[u]=u，所以y往上找一定会找到u； for(int i=hq[u];i!=-1;i=neq[i]) { int j=eq[i]; if(vis[j]) ans[w[i]]=find(j); } } 另外在询问中，对于一个x，可能有多个y，而且还要记录它们是第几个询问，所以我们不妨也用邻接表来存。 完整代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int N=500010;//开大一点 int h[N],e[2*N],ne[2*N],idx; int hq[N],eq[2*N],neq[2*N],w[2*N],idxq; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void addq(int a,int b,int c) { eq[idxq]=b,w[idxq]=c,neq[idxq]=hq[a],hq[a]=idxq++; } int ans[N],f[N],vis[N]; int find(int x) { return x==f[x]?x:f[x]=find(f[x]); } void Tarjin(int u) { vis[u]=1; f[u]=u; for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(!vis[j]) { Tarjin(j); f[j]=u;//这里是给j赋父节点 } } for(int i=hq[u];i!=-1;i=neq[i]) { int j=eq[i]; if(vis[j]) { ans[w[i]]=find(j); } } } int main() { memset(h,-1,sizeof h); memset(hq,-1,sizeof hq); int n,m,s; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;n;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x);//只说有边，没说是有向边 } for(int i=1;i&lt;=m;i++) { int x, y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); addq(x,y,i),addq(y,x,i); } Tarjin(s); for(int i=1;i&lt;=m;i++) { printf(&quot;%d\\n&quot;,ans[i]); } } LCA应用 LCA的应用在于用来处理图或树中指定端点的路径，LCA的存在相当于给了这条路径一个顺序，将这一条路拆成两半供我们操作。 下面的例1，就利用LCA对路径实现顺序操作的实现，因为差分数组一定是顺序访问才有效； 而例2，则是给出了利用上跳的原理遍历整条路，同时类比fa[][]数组来统计路径上的最小值。 LCA也可以理解成人为的给无向图赋上了方向，一条边如果有一个指定的顺序来进行操作，就会简化很多。 LCA+差分 eg1:Max Flow P 题目大意：有n个节点，用n-1条边连接，所有的节点都连通了。给出m条路劲，第i条路径为从节点si到ti。每给出一条路径，路径上所有节点的权值都加1，输出最大权值点的权值。 思路：“每给出一条路径，路径上所有节点的权值都加1”这句话很重要，很明显，暴力的思路是遍历这条路，然后将这条路上的点权都加1，但显而易见，会超时，但是这种很明显是对一段区间进行统一操作，很容易想到差分。我们接着往下想，差分是在一维区间中，在从前往后遍历的过程中将数累计出来，我们要想差分就一定要实现一个点先被访问，一个点后被访问，那么如何来实现呢？很明显对于题目中的无向图，没办法指定一条路径使m条路径中都是一个点先被访问，一个点后被访问。这里我们引入LCA，对于任意两个点，它们都有一个LCA点，这个点一定在这条路径上，所以我们可以以LCA为界，将路劲分为两半，我们可以先建立有向图，然后往下访问的过程中一定是先访问到LCA，那么如果我们在回溯的过程中开始累计，不就可以实现差分数组累计的过程嘛，另外要注意，LCA会被回溯两次，所以我们在LCA处要--，不能全减在fa[LCA][0]上。那么由此我们就实现了累计，剩下的，我们只要在遍历的过程中统计一下即可。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=50010; int h[N],e[2*N],ne[2*N],idx; int deep[N],vis[N],f[N][30],d[N]; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void dfs(int u,int fa) { deep[u]=deep[fa]+1; f[u][0]=fa; for(int i=1;(1&lt;&lt;i)&lt;=deep[u];i++) { f[u][i]=f[f[u][i-1]][i-1]; } for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(j!=fa) dfs(j,u); } } int LCA(int x,int y) { if(deep[x]&lt;deep[y]) swap(x,y); for(int i=20;i&gt;=0;i--) { if(deep[x]-(1&lt;&lt;i)&gt;=deep[y]) x=f[x][i]; } if(x==y) return x; for(int i=20;i&gt;=0;i--) { if(f[x][i]!=f[y][i]) { x=f[x][i]; y=f[y][i]; } } return f[x][0]; } int ans=0; void getans(int u) { vis[u]=true; for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(!vis[j]) { getans(j); d[u] += d[j]; } } ans = max(ans,d[u]); } int main() { memset(h,-1,sizeof h); int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=0;i&lt;n-1;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); add(x,y),add(y,x); } dfs(1,1); //printf(&quot;ok&quot;); for(int i=0;i&lt;k;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); int lca=LCA(x,y); d[x]++,d[y]++,d[lca]--,d[f[lca][0]]--; } getans(1); printf(&quot;%d&quot;,ans); } LCA+最大生成树 货车运输 题目大意：A 国有n 座城市，编号从1到n，城市之间有m条双向道路。每一条道路对车辆都有重量限制，简称限重。 现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 我们对于每辆货车，知道它的起点和终点。 思路：这里给的是图，所以两点之间的路径不只有一条，我们肯定是要最大的（沿途每段都最大），该如何确定呢？我们可以根据最小生成树来推出最大生成树，即将边按照权重从大到小排序，遍历每条边，判断每条边连接的两点的祖先是否连在一起，如果连在一起就说明两点之间已经有更大的路径可以将它们连通了，这条边肯定不会走，如果不连在一起就说明这边边必须走，那么把它加入最大生成树中即可。我们得到最大生成树，然后要想实现题目要求，两点之间走的路径一定是最大生成树中的边。这里实际上对于两点可以使用暴力来求，即从一点开始dfs，但是显而易见会超时，那么就要进行优化。我们引入LCA进行优化，LCA的实现过程就是两个点找最近公共祖先，这个最近公共祖先一定在路径上，那么我们在进行LCA查找的过程中就相当于遍历了这条路径，而且是以一种很高效的方式遍历了这条路径，在这个过程中，路径上边权的最小值自然可以得到。由于LCA查找的过程是不断上跳，那么我们就要用一个数组来记录，被跳过的这一段中的最小边权。 我们现在来讨论这个数组： j上跳2i，可以分成两段，分别是j~j-2(i-1) ,j-2(i-1)~j-2i，那么这一段的最小值即w[j][i]就是由这两段取最小得到的，这种递推，我们只要将初值(边界值，i=0)赋一下,剩下的就可以启动递推来计算。然后上跳过程中就可以直接用这个来统计。 至此我们就讨论完毕。该题的主要步骤就是：1.产生最大生成树；2.LCA预处理（分两部分：一部分dfs（）建立有向的树，另一部分预处理fa[][]和w[][]）；3.LCA找答案。 wq[j][i]=min(wq[j][i-1],wq[fa[j][i-1]][i-1]); //从小到大进行递推，只要递推开始赋值了就可，我们在预处理每棵树的时候赋了值 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100010; int n,m; int vis[N]; //kruscal算法最好用结构体来存边 struct edge{ int u,v,w; }e1[2*N],e2[2*N]; int h[N],e[N],ne[N],w[N]; int idx1,idx2; bool cmp(edge x,edge y) { return x.w&gt;y.w; } void add1(int a,int b,int c) { e1[idx1++]={a,b,c}; }//存原图 void add2(int a,int b,int c) { w[idx2]=c,e[idx2]=b,ne[idx2]=h[a],h[a]=idx2++; }//存最大生成树 int f[N]; int find(int x) { return x==f[x]?x:f[x]=find(f[x]); } void kruscal() { sort(e1,e1+idx1,cmp); for(int i=1;i&lt;=n;i++) f[i]=i;// for(int i=0;i&lt;idx1;i++) { int u=e1[i].u,v=e1[i].v; if(find(u)!=find(v)) { f[find(u)]=find(v);// add2(u,v,e1[i].w); add2(v,u,e1[i].w);// } } } int fa[N][30],wq[N][30]; int d[N]; void dfs(int u) { vis[u]=1; for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(!vis[j]) { fa[j][0]=u; wq[j][0]=w[i]; d[j]=d[u]+1; dfs(j);// } } } int LCA(int x,int y) { if(find(x)!=find(y)) return -1;//不连通，给的是图 int ans=1e9; if(d[x]&lt;d[y]) swap(x,y); for(int i=20;i&gt;=0;i--) { if(d[x]-(1&lt;&lt;i)&gt;=d[y]) { x=fa[x][i]; ans=min(ans,wq[x][i]);//在上跳过程中更新最小距离 } } if(x==y) return ans; for(int i=20;i&gt;=0;i--) { if(fa[x][i]!=fa[y][i]) { x=fa[x][i],y=fa[y][i]; ans=min(ans,wq[x][i]); ans=min(ans,wq[y][i]); } } ans=min(ans,wq[x][0]); ans=min(ans,wq[y][0]); return ans;//找最近公共祖先节点的过程中就遍历了这条路径 } int main() { memset(h,-1,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++)// { int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add1(a,b,c); } kruscal(); for(int i=1;i&lt;=n;i++) { if(!vis[i]) { d[i]=1;//这个点没被访问过，那么这个点一定是一棵树的起点（根节点），父节点是本身，上跳为正无穷 dfs(i); fa[i][0]=i;// wq[i][0]=1e9;// } } for(int i=1;i&lt;=20;i++) { for(int j=1;j&lt;=n;j++) { fa[j][i]=fa[fa[j][i-1]][i-1]; wq[j][i]=min(wq[j][i-1],wq[fa[j][i-1]][i-1]);//从小到大进行递推，只要递推开始赋值了就可，我们在预处理每棵树的时候赋了值 } } //printf(&quot;wq&quot;); int q; scanf(&quot;%d&quot;,&amp;q); for(int i=0;i&lt;q;i++) { int x,y; scanf(&quot;%d%d&quot;,&amp;x,&amp;y); int t=LCA(x,y); printf(&quot;%d\\n&quot;,t); } } LCA+二分 运输计划 题目大意：L 国有 n 个星球，还有 n−1 条双向航道，每条航道建立在两个星球之间，这 n−1 条航道连通了 L 国的所有星球。 小 P 掌管一家物流公司， 该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 ui号星球沿最快的宇航路径飞行到vi号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 j，任意飞船驶过它所花费的时间为 tj，并且任意两艘飞船之间不会产生任何干扰。 为了鼓励科技创新， L 国国王同意小 P 的物流公司参与 L 国的航道建设，即允许小 P 把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。 在虫洞的建设完成前小 P 的物流公司就预接了 m 个运输计划。在虫洞建设完成后，这 m 个运输计划会同时开始，所有飞船一起出发。当这 m 个运输计划都完成时，小 P 的物流公司的阶段性工作就完成了。 如果小 P 可以自由选择将哪一条航道改造成虫洞， 试求出小 P 的物流公司完成阶段性工作所需要的最短时间是多少？ 思路：所有飞船同时出发，当所有计划都完成了，那么任务就完成了，那么完成时间就是所有时间中的最大值，我们要求的是最大时间中的最小值。这里需要联想到二分，对这个时间进行二分。那么关键就转化成如何写check函数。我们有m条路径，肯定是要对这些路径进行遍历操作的，那我们由此联系LCA，我们定下最大长度len之后，遍历这些边，如果长度小于等于len自然无所谓，如果长度大于len，我们详细的遍历每一小段，如果这一小段的长度改成0后可以使这条路径的长度小于len，那么我们就将这一小段标记一下，对于m条路径，假如其中有x段的长度是大于len，如果有一小段被标记x次，那么只用把这一小段的长度改成0即可。那么我们实际上就完成了check函数。遍历这条路径的时候，我们可以分两边，u-&gt;LCA,v-&gt;LCA,每次只上跳一小段，标记路径的时候，虽然路径连两个点，我们用used[u]表示u到它的父节点的路径被标记几次，只需要用一个数组预处理下u到它父节点的距离，就可以很快实现判断。 实际实现中遇到的问题： m条路径的长度计算:d[u]+d[v]-2*d[lcd];d在建树dfs的时候进行计算，表示该点到根节点的距离 (这个方法可以用来快速计算图中任意两点之间的距离，以一点为根建立树，然后在建树的过程中将f[][]和d[]计算出来，然后想要得到两条路径之间的长度就直接用上述式子得到。另外f[][]在dfs中全部算了也行，dfs结束写个循环算也行) 另外我们可以用数组来存每个点到它父节点之间的距离，这个在dfs中实现 同时，想要快速遍历这条路径，也可以通过分别从两个点上跳到LCA来实现。而且这里上跳，每次可以上跳任意多次，因为我们得到了f[][]数组，通过这个数组，我们可以进行任意长度的上跳。将上跳长度转成2的幂相加就行。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=300010; struct Edge { int u,v,lca,dis; }ed[N]; int n,m; int h[N],e[2*N],ne[2*N],w[2*N],idx; void add(int a,int b,int c) { e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } bool cmp(Edge a,Edge b) { return a.dis&lt;b.dis;//细心一点呐，这里需要从小到大排，这里的错误导致后面check函数出问题 } int f[N][30],deep[N],d[N]; int up[N]; void dfs(int u,int fa)//每个点与它父节点之间肯定有路 { deep[u]=deep[fa]+1; f[u][0]=fa; for(int i=1;(1&lt;&lt;i)&lt;=deep[u];i++) f[u][i]=f[f[u][i-1]][i-1]; for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(j!=fa) { d[j]=d[u]+w[i]; up[j]=w[i];//存到父节点的距离 dfs(j,u); } } } int LCA(int u,int v) { if(deep[u]&lt;deep[v]) swap(u,v); for(int i=20;i&gt;=0;i--) { if(deep[u]-(1&lt;&lt;i)&gt;=deep[v]) u=f[u][i]; } if(u==v) return u; for(int i=20;i&gt;=0;i--) if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i]; return f[u][0]; } int used[N]; int check(int k) { if(ed[m].dis&lt;=k) return 1; int x=0,mx=0; memset(used,0,sizeof used); for(int i=m;i&gt;=1;i--)//算路径长度？ { if(ed[i].dis&lt;=k) break; x++;//表示有多少条路的长度大于len int u=ed[i].u,v=ed[i].v,dis=ed[i].dis-k,lca=ed[i].lca; while(u!=lca)//遍历u-&gt;lca这一段，每一小段中如果有路径的长度被减去后可以使总长度符合，那么就标记一下 { if(up[u]&gt;=dis) { used[u]++; mx=max(mx,used[u]);//统计被标记的最多次数，只有这个数大于等于x（需修改的路径数）,才能是满足要求 } u=f[u][0]; } while(v!=lca) { if(up[v]&gt;=dis) { used[v]++; mx=max(mx,used[v]); } v=f[v][0]; } if(x&gt;mx) return 0; } return 1; } int main() { memset(h,-1,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int sum=0; for(int i=1;i&lt;n;i++) { int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); sum += c; add(a,b,c); add(b,a,c); } dfs(1,1); //利用lca计算路径长度，求出到根节点的距离，进而计算 for(int i=1;i&lt;=m;i++) { int u,v; scanf(&quot;%d%d&quot;,&amp;u,&amp;v); int lca=LCA(u,v); int dis=d[u]+d[v]-2*d[lca];//计算dis ed[i]={u,v,lca,dis}; } sort(ed+1,ed+1+m,cmp); int l=0,r=300000000; int ans; while(l&lt;r) { int mid=(l+r)/2; if(check(mid)) r=mid,ans=mid; else l=mid+1; } printf(&quot;%d\\n&quot;,ans); } ","tags":[],"title":"LCA","feature":"","link":"https://s111z.github.io/post/lca/","stats":{"text":"25 min read","time":1441000,"words":5434,"minutes":25},"date":"2023-10-28 22:21:10","dateFormat":"2023-10-28"},{"content":"点分治 点分树（动态点分治） 分治FFT 线段树分治 “动态DP”&amp;动态树分治 关于分治，不需要考虑函数的具体细节，我们只要明确函数能实现什么功能，并正确调用即可。所以关键在于，明确在不断分小的过程中，什么操作是相同的，递归函数的意义就是来实现这一相同操作。 明确两点：如何往小的分（或是说一遍操作后，下一遍进行什么操作，要把层级理清楚）；每层操作时什么是相同的。 幂次方 题目大意：给定一个数n，我们将它拆成若干个2的幂相加，例如： 137=27+23+2^0 7=22+2+20 3=2+2^0 用2(c）表示2的c次幂 所以137=2(2(2)+2+2(0))+2(2+2(0))+2(0) 我们要使拆解后幂最高的只到2，请输出拆解后的结果。 思路：我们以137为例，第一次拆解即将它转化成二进制，然后再对拆出来的指数进一步拆解，拆解过程也是将它转成二进制。那么我们就可得到这是一层一层深入，一点一点将问题化小的过程，就是分治。 关于分治，不需要考虑函数的具体细节，我们只要明确函数能实现什么功能，并正确调用即可。所以关键在于，明确在不断分小的过程中，什么操作是相同的，递归函数的意义就是来实现这一相同操作。对于这道题，相同的操作就是拆解成二进制的过程，因为对不合适的指数进行拆解也是将其进行二进制拆解。 落实到这道题，有些细节需要处理一下，首先是拆解的过程，得到的二进制数上的01值是从右往左的，但是我们想要的输出是从左往右的，那么就需要将拆解结果先存一下，然后按照我们想要的顺序进行循环。另外在输出的时候涉及到括号和加号，需要判断一下在什么位置怎么输入比较好。 #include&lt;bits/stdc++.h&gt; using namespace std; int s[100]; void ct(int k)//2^k { if(k==0) { cout&lt;&lt;&quot;0&quot;; return; } if(k==1) { cout&lt;&lt;&quot;&quot;; return; } if(k==2) { cout&lt;&lt;&quot;2&quot;; return; } int i=0; vector&lt;int&gt;p;//因为要从大到小 while(k) { if(k%2) p.push_back(i); i++; k /= 2; } for(int i=p.size()-1;i&gt;=0;i--) { if(i!=p.size()-1) cout&lt;&lt;&quot;+&quot;; cout&lt;&lt;&quot;2&quot;; if(p[i]!=1)cout&lt;&lt;&quot;(&quot;; ct(p[i]); if(p[i]!=1)cout&lt;&lt;&quot;)&quot;; } } int main() { //这个题关键在于理解题目，第一次分是将原数转成二进制，第二次分是将指数转成二进制，第三次…… //本质上都是将数转成二进制 int n; cin&gt;&gt;n; int t=n; ct(n); } 点分治 这里一定要好好补一下这个题，上回为了一个题熬到半夜还是在上回。 言归正传，来讨论下这道题。 【模板】点分治 1 题目大意：给定一棵有n个点的树，询问树上距离为k的点对是否存在。(有m个询问) 数据范围：n &lt; 1e4,m &lt; 100 思路：这道题有两个卡点，一个是点分治，另一个是对询问的处理。 点分治： 对于这道题，暴力的解法就是对每个点进行dfs，不用多想，一定会超时。那么我们就要考虑优化，这里的优化是从树的重心开始访问，树上的点的距离分为两类，一类是跨过重心的，一种是在重心的同一侧，即在同一支路上。跨过重心的就是两个点到根节点的距离相加，不跨过重心的情况，我们可以对这条支路分治，把它转化为跨过重心的情况。那么问题就转化成了如何对跨过重心的情况进行处理。我们的处理方式是找出重心，计算所有点到重心的距离，将这些距离写入dis[],对dis排序，然后用尺取法（双指针）统计出和为k的有多少对，当然，这样的话，在一条支路上的会被误统计进去，因为我们只从数值上进行考虑，同一支路上的点距离不能这么算，对此，我们的解决办法就是，对于重心的每一个子节点进行一次同样的getans()处理，再用前面的结果减去这里得到的结果。 对询问的处理，这里才是卡点，我们按照上面的叙述，很容易将代码写成对于每一个询问都建一遍树，但是实际上，这样会超时，所以我们的处理是，用一个数组来记录询问，同时用一个数组ans来记录每个询问的答案，getans()函数再加一个自变量sign，对于重心的查找时，让sign=1，里面每次等于k的时候，ans[i]+=sign;对于重心子节点查找时，让sign=-1,里面每次等于k的时候，ans[i]-=sign;这样就是实现了ans[]的统计，我们只用在主函数中执行一次fz(),在getans()中遍历ask[]数组，进而获取ans[]。然后遍历ans[],如果ans[i]非0，就判是，否则判否。 每一块函数: 找重心： void getroot(int u,int fa)//x为当前点，fa为父亲节点 { f[u]=0,siz[u]=1;//f表示这个点最大子树的大小，siz是这个点子树大小的和 for(int i=h[u];i!=-1;i=ne[i])//枚举儿子 { int y=e[i]; if(use[y]||y==fa) continue;//use表示之前遍历过了，这里没啥用 getroot(y,u);//往下遍历 siz[u]+=siz[y]; f[u]=max(f[u],siz[y]);//更新f } f[u]=max(f[u],Siz-siz[u]);//Siz表示在现在这棵子树中点的总数，开始时Siz=n，除了枚举的儿子所在的子树外，还有一棵子树是上面的那一堆，容斥原理 if(f[u]&lt;mx) { mx=f[u]; rt=u;//更新root } } 获得到根节点的距离 void getd(int x,int fa) { dis[++cnt]=d[x];//d[x]实际上可以通过增加一个自变量来替换，主要是记录x点对应的长度，这个长度是在上一层中得到的，所以要么增加一个自变量传入函数，要么用全局变量d[]来记录。 for(int i=h[x];i!=-1;i=ne[i]) { int j=e[i]; if(j==fa||use[j]) continue; d[j]=d[x]+w[i]; getd(j,x); } } 获得ans[] void getans(const int &amp;x,int w,const int sign) { cnt=0; d[x]=w; getd(x,0); sort(dis+1,dis+1+cnt); for(int i=1;i&lt;=m;i++)//这里就是遍历处理询问 { int l=1,r=cnt; while(l&lt;r)//用二分优化一下也行，但对于这题没那么必要 { if(dis[l]+dis[r]&lt;=ask[i]) { if(dis[l]+dis[r]==ask[i]) ans[i] += sign; ++l; } else --r; } } } 分治函数 void fz(const int &amp;x)//x就是重心 { use[x]=1; getans(x,0,1); for(int i=h[x];i!=-1;i=ne[i]) { int j=e[i]; if(use[j]) continue; getans(j,w[i],-1); Siz=siz[j],mx=1e9+7; getroot(j,x); fz(rt); } } 完整代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int N=10005; const int INF=10000005; int k; int h[40010],e[40010],ne[40010],w[40010],idx; int use[20010]; int d[20010],dis[N]; int f[20010],siz[20010]; int cnt,Siz,rt=1; int ans[N]; int mx=1e9+7; int n,m; int ask[N]; void add(const int &amp;a,const int &amp;b,const int &amp;c) { w[idx]=c,e[idx]=b,ne[idx]=h[a],h[a]=idx++; w[idx]=c,e[idx]=a,ne[idx]=h[b],h[b]=idx++; } //求重心 void getroot(int u,int fa)//x为当前点，fa为父亲节点 { f[u]=0,siz[u]=1;//f表示这个点最大子树的大小，siz是这个点子树大小的和 for(int i=h[u];i!=-1;i=ne[i])//枚举儿子 { int y=e[i]; if(use[y]||y==fa) continue;//use表示之前遍历过了，这里没啥用 getroot(y,u);//往下遍历 siz[u]+=siz[y]; f[u]=max(f[u],siz[y]);//更新f } f[u]=max(f[u],Siz-siz[u]);//Siz表示在现在这棵子树中点的总数，开始时Siz=n，除了枚举的儿子所在的子树外，还有一棵子树是上面的那一堆，容斥原理 if(f[u]&lt;mx) { mx=f[u]; rt=u;//更新root } } //求到重心的距离 void getd(int x,int fa) { dis[++cnt]=d[x]; for(int i=h[x];i!=-1;i=ne[i]) { int j=e[i]; if(j==fa||use[j]) continue; d[j]=d[x]+w[i]; getd(j,x); } } //求答案 void getans(const int &amp;x,int w,const int sign) { cnt=0; d[x]=w; getd(x,0); sort(dis+1,dis+1+cnt); for(int i=1;i&lt;=m;i++) { int l=1,r=cnt; while(l&lt;r) { if(dis[l]+dis[r]&lt;=ask[i]) { if(dis[l]+dis[r]==ask[i]) ans[i] += sign; ++l; } else --r; } } } //分治划分 void fz(const int &amp;x)//x就是重心 { use[x]=1; getans(x,0,1); for(int i=h[x];i!=-1;i=ne[i]) { int j=e[i]; if(use[j]) continue; getans(j,w[i],-1); Siz=siz[j],mx=1e9+7; getroot(j,x);//找子树中的重心 fz(rt); } } signed main() { f[0]=1e9+7; memset(h,-1,sizeof h); scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n-1;i++) { int a,b,c; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c); add(a,b,c); } Siz=n; getroot(1,1); int root=rt; for(int i=0;i&lt;=n;i++)use[i]=0; for(int i=1;i&lt;=m;i++) { scanf(&quot;%d&quot;,&amp;ask[i]); } fz(root); for(int i=1;i&lt;=m;i++) { if(ans[i]&gt;0) printf(&quot;AYE\\n&quot;); else printf(&quot;NAY\\n&quot;); } } ","tags":[],"title":"分治","feature":"","link":"https://s111z.github.io/post/fen-zhi/","stats":{"text":"11 min read","time":634000,"words":2415,"minutes":11},"date":"2023-10-27 14:00:15","dateFormat":"2023-10-27"},{"content":"Divisiblity of Differences 题目大意：有一个大小为n的多集，我们要从中选k个数，使得任意两数之差可以整除m，问是否成立。 思路：任意两数之差可以整除m，仔细想想就会发现，只要它们模m的结果相同即可。所以我们需要做的就是统计，每个数模上k后的值，然后统计每个余数对应的数有几个，如果个数大于等于k，那么就成立。 #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt;p[100010]; int main() { int n,k,m;//n是数组个数，k是需要挑的个数，m是除数 scanf(&quot;%d%d%d&quot;,&amp;n,&amp;k,&amp;m); map&lt;int,int&gt;mp; for(int i=0;i&lt;n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); mp[x%m]++; p[x%m].push_back(x);//因为要输出原数，所以还是要记一下 } int f=-1; for(auto t:mp) { if(t.second&gt;=k) { f=t.first; break; } } if(f==-1) printf(&quot;No&quot;); else { printf(&quot;Yes\\n&quot;); int c=0; for(auto it:p[f]) { cout&lt;&lt;it&lt;&lt;&quot; &quot;; c++; if(c==k) break; } } } Creating a Character 题目大意：我们给定数字st，it表示角色初始的力量和智慧，现在有n个技能点，可以分给力量和智慧，我们现在要求能够创造出多少个不同的角色，st和it只要有一个不同就算不同。另外要求st严格大于it，算一个合格的角色，只有合格才算角色。 思路：这道题切忌st和it都关注，我们只要关注一个量，求出其上下限即可。这里我们看st，上限是将n全部分给它，下限是st+es-1=it+n-es,但是要注意有st远小于it的情况，即st+n&lt;=it，这种直接判否就可。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int st,it,n; scanf(&quot;%d%d%d&quot;,&amp;st,&amp;it,&amp;n); if(st+n&lt;=it) { printf(&quot;0\\n&quot;); } else { int c=it+n+1-st; //cout&lt;&lt;&quot;c=&quot;&lt;&lt;c&lt;&lt;endl; int x=ceil(c*1.0/2); //cout&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;endl; x=max(x,0); cout&lt;&lt;n-x+1&lt;&lt;endl; } } } k-th divisor 题目大意：给定两个数n、k，要求n的第k小的因数。 思路：第一种方法是暴力；第二种方法是对顶堆，但实际上是没必要的； #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { int n,k; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); set&lt;int&gt;s; for(int i=1;i&lt;=n/i;i++) { if(n%i==0) s.insert(i),s.insert(n/i); } if(s.size()&gt;=k) { vector&lt;int&gt;a; for(auto t:s) a.push_back(t); printf(&quot;%lld\\n&quot;,a[k-1]); } else printf(&quot;-1\\n&quot;); } //set最大能放268435455个元素，差不多是2e8，再大就要考虑别的数据结构了。 Add One 题目大意：给定一个数n，每次操作将每一位数加1，得到一个新的数，然后继续进行操作，总共操作k次，问最后得到的数有多少位。（例 对19进行一次操作，得到210） 思路1：每一位上的数字实际上都是0-9，那我们干脆从10开始找规律：我们对10进行次数讨论： d[i]表示进行i次操作后的位数 次数i： 0-8：d[i]=2; 9：d[i]=3; i&gt;9:d[i]=d[i-1]+d[i-2]; 这里实际上需要多写一些找规律。 实际上单纯 找规律，不容易推出来，详细的思路见思路2后 实现1： #include&lt;bits/stdc++.h&gt; using namespace std; int dp[200010]; const int mod=1e9+7; int main() { for(int i=0;i&lt;9;i++) dp[i]=2; dp[9]=3; for(int i=10;i&lt;=200010;i++) dp[i]=dp[i-9]+dp[i-10],dp[i]%=mod; int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int ans=0; while(n) { int x=n%10; if(x+m &gt;= 10) ans += dp[x+m-10]; else ans += 1; ans %= mod; n /= 10; } printf(&quot;%d\\n&quot;,ans); } } 思路2：d[i][j]//对i进行j次操作 i只能取0-9的数， 当进行的操作不会让这个数升位的时候，就是1；如果让这个数变成10，那么就用 d[i][j]=(d[0][i+j-10]+d[1][i+j-10])%mod; 来计算长度，d[0][]、d[1][]会随着次数的增加而改变。 //by czy #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; int t,dp[10][200015],n,m,res; signed main() { ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); for(int i=0;i&lt;10;++i) { dp[i][0]=1; } for(int i=1;i&lt;200010;++i) { for(int j=0;j&lt;=9;++j) { if(i+j&lt;=9) { dp[j][i]=1; } else { dp[j][i]=(dp[0][i+j-10]+dp[1][i+j-10])%1000000007; } } } cin&gt;&gt;t; while(t--) { cin&gt;&gt;n&gt;&gt;m; res=0; while(n) { res=res+dp[n%10][m]; res=res%1000000007; n=n/10; } cout&lt;&lt;res&lt;&lt;endl; } } 思路1和思路2实际上是差不多的，这道题的关键在于不要考虑加后能得到什么，而是去考虑加后能有多少位，这才是关键，那么关于数字我们只考虑0-9就行，当操作次数会让它升位时，就将它单独列出来，然后第二个思考点就是，如何升位，首先它加到10的时候就会升成2，然后后面如果还需要操作就是对10进行的，那就等价于对0和1进行操作，但此时操作数已经减小，因为要先变成10，对0和1的操作又回到刚刚，操作次数会不会让它升位，不升位就是1，升位就是再对0和1进行操作，操作数进一步减小，依次类推就会发现本质上是不断划分成操作数更小的0和1，然后进行操作。那么实际上我们只考虑对0，1的操作次数就行，然后不断累计,所以由此产生优化：(这样优化后数据范围可以再扩大一点) #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; int t,dp[10][200015],n,m,res; signed main() { for(int i=0;i&lt;2;++i) { dp[i][0]=1; } //dp[i][j] i表示对哪个数进行操作，j表示操作多少次 for(int i=1;i&lt;200010;++i)//操作次数 { for(int j=0;j&lt;2;++j)//哪个数 { if(i+j&lt;=9) { dp[j][i]=1; } else { dp[j][i]=(dp[0][i+j-10]+dp[1][i+j-10])%1000000007; } } } scanf(&quot;%d&quot;,&amp;t); while(t--) { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); res=0; while(n) { int x=n%10; if(x+m&lt;10) res+=1; else res += (dp[0][x+m-10]+dp[1][x+m-10])%1000000007; res=res%1000000007; n=n/10; } printf(&quot;%d\\n&quot;,res); } } 思路3：暴力 a-Good String 题目大意：给定一个字符串s,我们定义c-good串：前半段或者后半段是全是字符c,另外半段是c+1-good串，如“cdbbaaaa”： cdbb aaaa cd bb c d 可以不断分成两段，可发现分成的两段是满足题目要求的。 我们一次操作可以更改一个字母，我们要求的是将s变成a-good串，最少需要多少次操作。 思路：这道题很明显是分治，从中间分，不断把子串分小。我们需要修改，从第一次分开始看，第一次分后得到两段，我们需要看看是将前半段统一成a，还是将后半段统一成a,这里有两个需要考虑的因素，一个是前半段需要修改多少个元素，一个是后半段需要修改多少个元素，对每种情况的前后求和，然后取最小值即可，划分之后计算过程一样，那么直接递归调用这个计算函数即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int fz(string s,char c) { if(s.size()==1) return s[0]!=c;//等于就返回0，不用更改 int mid=s.size()/2;//必须从中间分 abcd n=2^k，那么就是说这里永远是整数 int q=fz(string(s.begin(),s.begin()+mid),c+1);//这里s.begin()+mid实际上不会算进前一半 q += mid-count(s.begin()+mid,s.end(),c); int h=fz(string(s.begin()+mid,s.end()),c+1); h += mid-count(s.begin(),s.begin()+mid,c); return min(q,h); } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; string s; cin&gt;&gt;n&gt;&gt;s; int ans=fz(s,'a'); cout&lt;&lt;ans&lt;&lt;endl; } } Unusual Matrix 题目大意：我们给定一个n阶矩阵，矩阵的元素只含0和1，我们规定两种操作：1.将一整行的数全部取异或；2.将一整列的数全部取异或（异或的意义实际就是将0变成1或者将1变成0）。我们给定两个矩阵a,b；问能否通过操作将a变成b。 思路：这道题看似麻烦，既要进行行变化又要进行列变化，但实际上行列的变化顺序对结果不产生影响，如果可以就是可以，就那么多操作，操作顺序怎样都可以；如果不可以就是不可以。那么我们只要指定一种操作顺序，然后判断可不可以就行。 而这里我们指定的操作顺序为：先遍历第一行，如果a，b中对应的元素不相同，那么就将一整列进行操作；遍历结束之后，再遍历第一列，如果对应元素不相同，那么就将对应的一整行进行操作，这样所有的行列都根据要求进行了操作。 #include&lt;bits/stdc++.h&gt; using namespace std; int a1[2000][2000]; int b[2000][2000]; int a2[2000][2000]; int n; int check1()//先进行列变化 { for(int i=0;i&lt;n;i++) { if(a1[0][i]!=b[0][i]) { for(int j=0;j&lt;n;j++) { a1[j][i] ^= 1; } } } //行变化 for(int i=0;i&lt;n;i++) { int it=(a1[i][0]^b[i][0]); for(int j=1;j&lt;n;j++) { if(it!=(a1[i][j]^b[i][j])) return 0; } } return 1; } int check2() { for(int i=0;i&lt;n;i++) { if(a2[i][0]!=b[i][0])//遍历第一列 { for(int j=0;j&lt;n;j++) { a2[i][j] ^= 1; } } } //列变化 for(int i=0;i&lt;n;i++) { int it=(a2[0][i]^b[0][i]); for(int j=1;j&lt;n;j++) { if(it!=(a2[j][i]^b[j][i])) return 0; } } return 1; } int main() { int t; cin&gt;&gt;t; while(t--) { cin&gt;&gt;n; for(int i=0;i&lt;n;i++) { string s; cin&gt;&gt;s; for(int j=0;j&lt;n;j++) { a1[i][j]=s[j]-'0'; a2[i][j]=s[j]-'0'; } } for(int i=0;i&lt;n;i++) { string s; cin&gt;&gt;s; for(int j=0;j&lt;s.size();j++) { b[i][j]=s[j]-'0'; } } if(check1()) printf(&quot;YES\\n&quot;); // else if(check2()) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } Lost Numbers 题目大意：交互题，给定6个数-4,8,15,16,23,42，我们通过4次询问，每次询问可以询问任意两个数的乘积，进而得出它的顺序。 思路：这道题我们从1开始，每次询问a[i]*a[i+1],然后找出15或者23的位置，然后就可以进一步将前五个数推出，然后再看哪个数没有出现，就将这个数填在第六位。这道题的推理很简单，难点在于交互，交互 的意思是，由你给输入，但是输入被写在cout区域，oj给出输出，但输出写在cin区。 cout&lt;&lt;&quot;?&quot;&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt; i+1 &lt;&lt;endl;//进行输入 scanf(&quot;%d&quot;,&amp;ans);//获取系统输出 fflush(stdout);//刷新输出区 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int a[]={0,4,8,15,16,23,42}; int ans; int res[10]; int sres[10]; memset(res,-1,sizeof res); memset(sres,-1,sizeof sres); for(int i=1;i&lt;=4;i++) { cout&lt;&lt;&quot;?&quot;&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i+1&lt;&lt;endl; fflush(stdout); scanf(&quot;%d&quot;,&amp;ans); res[i]=ans; } int flag=1; for(int i=1;i&lt;4;i++) { if(res[i]%23==0&amp;&amp;res[i+1]%23==0) //23在中间 { sres[i+1]=23; sres[i]=res[i]/23; sres[i+2]=res[i+1]/23; int t=i+2; while(t&lt;=4) { sres[t+1]=res[t]/sres[t]; t++; } t=i-1; while(t&gt;=1) { sres[t]=res[t]/sres[t+1]; t--; } flag=0; } if(res[1]%23==0&amp;&amp;res[2]%23!=0)//23在开头 { sres[1]=23; int t=2; while(t&lt;=5) { sres[t]=res[t-1]/sres[t-1]; t++; } flag=0; } if(res[i]%15==0&amp;&amp;res[i+1]%15==0) //15在中间 { sres[i+1]=15; sres[i]=res[i]/15; sres[i+2]=res[i+1]/15; int t=i+2; while(t&lt;=4) { sres[t+1]=res[t]/sres[t]; t++; } t=i-1; while(t&gt;=1) { sres[t]=res[t]/sres[t+1]; t--; } flag=0; } if(res[1]%15==0&amp;&amp;res[2]%15!=0)//15在开头 { sres[1]=15; int t=2; while(t&lt;=5) { sres[t]=res[t-1]/sres[t-1]; t++; } flag=0; } } if(flag)//15和23不在前四个数中 { if(res[4]%23==0) { sres[5]=23; int t=4; while(t&gt;=1) { sres[t]=res[t]/sres[t+1]; t--; } } if(res[4]%15==0) { sres[5]=15; int t=4; while(t&gt;=1) { sres[t]=res[t]/sres[t+1]; t--; } } } for(int i=1;i&lt;=6;i++) { if(find(sres+1,sres+6,a[i])==sres+6) { sres[6]=a[i]; break; } } cout&lt;&lt;&quot;!&quot;&lt;&lt;&quot; &quot;; for(int i=1;i&lt;=6;i++) { printf(&quot;%d &quot;,sres[i]); } } GameGame 题目大意:k和朋友做游戏，两人初始分数都是0，现有一个数组a[],他们轮流从a中选一个数，然后用这个数与自己的分数进行异或，最后谁的分高，谁就赢了，如果两人分数相等就平局，问k的状态。 思路：这道题的核心在与谁的谁的最高位1所在的位数最高（当然这里所说的最高位是从前往后访问，两者不相等的第一位），最开始都是0，所以不影响最高位1，那么我们就统计a[]中每一个数的每一位是否为1，最后得到两个数组，f0[],f1[],表示第i位0或1的个数。然后从前往后访问数组。如果1的个数是偶数，那么一人一半，没什么影响，10=1,00=0,剩下的0无论怎么分都不影响；假设没有0或者偶数个0，如果1的个数是奇数，如果为3，7，11，……那么一人一个，最后一个肯定分给k，而且此时之前两个人都是1，那么朋友就赢了；如果是5，9，……，那么在分给k之前都是0，那么k胜利；据此写出代码,在循环中判输赢，如果没盘判出来就输出平局。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); int a0[40],a1[40]; memset(a0,0,sizeof a0); memset(a1,0,sizeof a1); for(int i=1;i&lt;=n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); for(int j=30;j&gt;=0;j--) { if(x&gt;&gt;j&amp;1) a1[j]++; else a0[j]++; } } int flag=1; for(int i=30;i&gt;=0;i--) { if(a1[i]) { if(a1[i]%4==3&amp;&amp;a0[i]%2==0) { printf(&quot;LOSE\\n&quot;); flag=0; break; } else if(a1[i]%2)//如果能整除2，一人一个这样分，最高位相同就没有比较的意义了 { printf(&quot;WIN\\n&quot;); flag=0; break; } } } if(flag) printf(&quot;DRAW\\n&quot;); } } ps:涉及到位运算的题目，就将数视为二进制数来考虑 Weights Assignment For Tree Edges 题目大意：给定一个数组b[],b[i]表示i的父节点；我们要赋一个dist[]数组，dist[i]表示从根节点到i路径上所有点的点权和，要求dist[root]=0,同时给定一个数组p[],要求dist[p[i]]&lt; dist[p[i+1]]，最后输出每个点的点权。 思路：按照dist[]的定义，一定可以得到dist[父]小于dist[子]，我们按照p[]的顺序来给dist[]赋值，在赋值之前判断一下它的父节点的dist有没有被赋值，如果没被赋值，那么就直接输出-1，因为如果父在p中的位置在子后面，赋到的值就比子大，是不符合dist定义的。在输出点权的时候，我们对于每个点只要输出dist[父]-dist[i]就可。 #include&lt;bits/stdc++.h&gt; using namespace std; int b[200010],p[200010],dist[200010]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;p[i]); memset(dist,-1,sizeof dist); if(p[1]!=b[p[1]])//因为要按照p的顺序来赋值，所以p[1]必须是根节点 { printf(&quot;-1\\n&quot;); continue; } dist[p[1]]=0; int flag=1; for(int i=2;i&lt;=n;i++) { if(dist[b[p[i]]]==-1) { printf(&quot;-1\\n&quot;); flag=0; break; } dist[p[i]]=dist[p[i-1]]+1; } if(flag) { for(int i=1;i&lt;=n;i++) { printf(&quot;%d &quot;,dist[i]-dist[b[i]]); } printf(&quot;\\n&quot;); } } } Circle of Monsters 题目大意：n个角色，站成一圈，每个角色的血量为a，它死后会对下一个角色产生b的暴击，我们每次开枪只能对一个角色产生一点伤害，我们要求至少需要开几枪可以杀死所有角色。 思路：这道题是贪心题，思路比较巧，我们将一个角色的血量分成两部分，一部分是被暴击所伤的，一部分是需要补的枪数，如果被暴击所伤的大于自己的血量就不用补枪。我们考虑两种极端的情况，全都可以被暴击杀死，那么总的补枪数就是0，我们只要挑一个血量最少的开枪，就是最小开枪数；全都不能被暴击杀死，那么补枪数累加之后再加上最小暴击就可，因为它需要补枪的那一部分已经被考虑了，再加上暴击就可以杀死第一个，触发暴击。核心在于，第一个杀谁。 由上图，所有怪兽都分为以上两种情况，然后对于第一个打的一定是二选一的，选第一个就要打a[i]枪，选后一个就要打b[i]枪，肯定选小的。 #include &lt;bits/stdc++.h&gt; using namespace std; #define forn(i, n) for (int i = 0; i &lt; int(n); ++i) typedef long long li; const int N = 300 * 1000 + 13; int n; li a[N], b[N]; void solve() { scanf(&quot;%d&quot;, &amp;n); forn(i, n) scanf(&quot;%lld%lld&quot;, &amp;a[i], &amp;b[i]);//a是血量，b是暴击伤害 li ans = 0, mn = 1e18; forn(i, n)//[0,n-1] { int ni = (i + 1) % n;//算下一个是谁 li val = min(a[ni], b[i]);//下一个的血量和当前这个的暴击去min ans += a[ni] - val; //a[ni]&gt;=b[i],val=b[i],打完当前这个要打死下一个还需要几枪 //a[ni]&lt;b[i],打下个需要补0枪 mn = min(mn, val); //val全等于a[ni],只要打死一个，就全死了，那就打死a[i]最小的即可 //全为b[i]的话，补枪全部已经算上，但是第一个的暴击无处可来，但是它的a已经被加了一部分了，剩下一部分就是它被暴击的，我们再加上即可 //混合其实同理，每一个都分为被暴击和补枪两部分， //val=a[ni]就是说，可以被暴击杀死，但是暴击可能不会被触发，那么就需要手动开枪 //val=b[ni]就是说，不能被暴击杀死，需要补枪，但补枪部分同一加了，也是可能无法开始暴击，需要手动开枪 //但是a[ni]的其中一部分已经被加上了，只用把另一部分加上即可，这部分刚好是暴击。4 } ans += mn; printf(&quot;%lld\\n&quot;, ans); } int main() { int T; scanf(&quot;%d&quot;, &amp;T); forn(i, T) solve(); } ","tags":[],"title":"ACDC16","feature":"","link":"https://s111z.github.io/post/acdc16/","stats":{"text":"23 min read","time":1345000,"words":4878,"minutes":23},"date":"2023-10-25 19:08:09","dateFormat":"2023-10-25"},{"content":"时间安排： 周一休息 周二、周三：完成ACDC 10道题并写出题解 周四、周五：专题模板练习（总结模板） 周六、周日：一场cf模拟、一场女生赛模拟 专题顺序： 一、基础算法 排序 二分 高精度 前缀和与差分 双指针算法 位运算 离散化 区间合并 二、数据结构 链表与邻接表：树与图的存储 栈与队列：单调队列、单调栈 kmp Trie 并查集 堆 Hash表 三、搜索与图论 DFS与BFS 树与图的遍历：拓扑排序 最短路 最小生成树 二分图：染色法、匈牙利算法 四、数学知识 质数 约数 欧拉函数 快速幂 扩展欧几里得算法 中国剩余定理 高斯消元 组合计数 容斥原理 简单博弈论 五、动态规划 背包问题 线性DP 区间DP 计数类DP 数位统计DP 状态压缩DP 树形DP 记忆化搜索 六、贪心 ","tags":[],"title":"ACM训练计划","feature":"","link":"https://s111z.github.io/post/acm-xun-lian-ji-hua/","stats":{"text":"1 min read","time":52000,"words":250,"minutes":1},"date":"2023-10-23 19:48:05","dateFormat":"2023-10-23"},{"content":"Morning 题目大意：键盘上的数按照“1234567890”排列，每次只能进行移动光标或者选择这两种操作之一，求输入一个四位数的PIN码至少需要操作多少次。（光标最开始在1处） 思路：就是个模拟题，思路很简单，将PIN码转化成int[]，用一个变量来表示光标当前位置，然后遍历int[]即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { string s; cin&gt;&gt;s; int a[5]; for(int i=0;i&lt;s.size();i++) { if(s[i]=='0') a[i]=10; else a[i]=s[i]-'0'; } int c=0,k=1; for(int i=0;i&lt;4;i++) { c += abs(a[i]-k)+1; k=a[i]; } cout&lt;&lt;c&lt;&lt;endl; } } Chemistry 题目大意：给定一个长为n的字符串s和一个整数k，问能否在恰好删除k个字符的情况下，使s删除重排后为回文串，空字串也是回文串。 思路：这题的核心在于字符串中每个字符出现次数的奇偶性，最多只能有一个为奇数，那那么只用统计字符数为奇数的有多少个，个数&lt;=k，就可以，因为个数小于等于k就可以将所有字符的个数都变成偶数，那么此时（k-个数）为奇数还是为偶数都可以成立；个数==k+1其实也可，删完只留一个，为奇数的，也可以构成回文串；个数&gt;k+1的话，删完至少剩俩为奇数的，一定不可以。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { int n,k; string s; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); cin&gt;&gt;s; map&lt;char,int&gt;mp; for(int i=0;i&lt;s.size();i++) mp[s[i]]++; int c=0; for(auto it:mp) { if(it.second%2) c++; } if(c&gt;k+1) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); } } Raspberries 题目大意：我们给定一个数组a，对于一个操作，就是挑一个ai,然后ai++;我们给定一个数k，要求至少操作多少次，使得最后ai的的乘积可以整除k； 思路：实际上很简单，2&lt;=k&lt;=5,想要整除，数组中一定有能够整除它的数，我们只用写一个循环，计算出每一个数要想整除它需要操作多少次，取最小值即可，另外对于4，单独处理一下，因为数组中如果 ","tags":[],"title":"Codeforces Round 905 (Div. 3)","feature":"","link":"https://s111z.github.io/post/codeforces-round-905-div-3/","stats":{"text":"3 min read","time":157000,"words":618,"minutes":3},"date":"2023-10-22 23:40:43","dateFormat":"2023-10-22"},{"content":"Simple Design 题目大意：给定一个数x和k，要求出最小的y&gt;=x,使y的各个位数上的和可以整除k。（k&lt;=10） 思路：这道题看似麻烦，但实际很简单，因为求的是各个数位上的和，所以我们可以一个一个在x的基础上进行累增，而且因为k&lt;=10,所以不用累增太多就可以找到目标值。 #include&lt;bits/stdc++.h&gt; using namespace std; int get(int k) { int c=0; while(k) { c += k%10; k /= 10; } return c; } int main() { int t; cin&gt;&gt;t; while(t--) { int x,k; scanf(&quot;%d%d&quot;,&amp;x,&amp;k); for(int i=x;i;i++) { int c=get(i); if(c%k==0) { printf(&quot;%d\\n&quot;,i); break; } else { int it=i; while(get(it)%k!=0) it ++; cout&lt;&lt;it&lt;&lt;endl; break; } } } } Haunted House 题目大意：给定一个数n，和一个长为n的二进制数，我们每次可以交换相邻的两个数，最终需要判断能否通过交换使得到的数能够整除2^i（1&lt;=i&lt;=n），如果不能，则输出-1。 思路：能够整除2，那么末位是0即可，能够整除4，则后两位为0，能整除8，就是后三位为0；依次类推，我们可以发现，只用统计二进制数中有多少个0，即可依次判断能否整除2的多少次方。至于交换，将前面的数换到后面来，无论多少个数，无论怎么换，实际上都到最后几个的话是等价的，那么我们对交换进行累计即可。 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long signed main() { int t; cin&gt;&gt;t; while(t--) { int n; scanf(&quot;%lld&quot;,&amp;n); string s; cin&gt;&gt;s; int c=0; vector&lt;int&gt;p; for(int i=0;i&lt;s.size();i++) { if(s[i]=='0') c++,p.push_back(i); } reverse(p.begin(),p.end()); //移动是等价的,移到到s.size()-1 int cnt=0; for(int i=1;i&lt;=n;i++) { if(p.size()&gt;=i) { cnt += s.size()-i-p[i-1]; //一定要注意，这里可能爆int，要用long long类型 cout&lt;&lt;cnt&lt;&lt;&quot; &quot;; } else printf(&quot;-1 &quot;); } cout&lt;&lt;endl; } } Medium Design 题目大意：给定n,m；n表示有多少个可操作子区间，m表示整个区间的长度（区间初值为0），我们对于每个可操作子区间可以选择将子区间内的所有数都加1，也可以不对该子区间进行操作。我们要求最后整个区间中最大值-最小值为多少。 思路：这道题的第一个难点就是找出区间重叠最多的位置重叠了多少个区间，这里有个很精妙的算法，扫描算法： vector&lt;pair&lt;int,int&gt;&gt;p; for(int i~) { cin&gt;&gt;x&gt;&gt;y; p.push_back({x,1}); p.push_back({y+1,-1}); } sort(p.begin(),p.end()); int c=0,mx=0; for(auto t:p) { if(t.second==1) c++; else c--; mx=max(mx,c); } 这里wo'men'j ","tags":[],"title":"Codeforces Round 904 (Div. 2)","feature":"","link":"https://s111z.github.io/post/codeforces-round-904-div-2/","stats":{"text":"4 min read","time":199000,"words":738,"minutes":4},"date":"2023-10-22 17:58:20","dateFormat":"2023-10-22"},{"content":"Make a Power of Two 题目大意：给定一个数字，我们可以对其进行两个操作: 1.在其左右添加字符 2.从任意位置抹掉字符 我可进行任意次操作，要使操作后的数是2的任意次幂。 思路：这道题在看到这两个操作的时候就应该与字符串匹配联系起来，事实上，确实是字符串匹配，我们将数字转化成字符串，预处理出来2的任意次幂对应的字符串，然后进行匹配，取最小值即可。另外要注意，2的幂最好处理的大一点。 #include&lt;bits/stdc++.h&gt; using namespace std; string s[100]; #define int long long string zh(int m) { string s; while(m) { s+=m%10+'0'; m /= 10; } reverse(s.begin(),s.end()); return s; } signed main() { int t=1ll; int k=0; while(1) { s[k++]=zh(t); if(t&gt;2e18) break; t *= 2; } cin&gt;&gt;t; while(t--) { int n; cin&gt;&gt;n; string s1=zh(n); int mi=100000000; for(int i=0;i&lt;k;i++) { int x=0,y=0,c=0; while(x&lt;s1.size()&amp;&amp;y&lt;s[i].size()) { if(s1[x]==s[i][y]) c++,y++; x++; //s1会被遍历，因为其中和s[i]不等的字符会被擦掉 } c = s1.size()-c+s[i].size()-c; //s1.size()是被擦掉的字符，s[i].size()-c是要添加的字符 mi=min(mi,c); } cout&lt;&lt;mi&lt;&lt;endl;; } } 上述代码中的zh()还可被替换成to_string() ps:string s[]与vector类似 ","tags":[],"title":"cf1300练习","feature":"","link":"https://s111z.github.io/post/cf1300-lian-xi/","stats":{"text":"2 min read","time":99000,"words":359,"minutes":2},"date":"2023-10-22 10:01:46","dateFormat":"2023-10-22"},{"content":"类： 1.类的定义 2.成员函数的定义 3.创建对象调用方法 class student{ public: int num; private: int name; } 类名：student 属性：num public是公有，private是私有，公有是可以在其他类和主函数中访问修改，private是只能在类的内部进行访问 没有private的类相当于结构体 类被定义后就可以创建类的对象 student a; 成员函数的重载： 不同的函数可能有相同的函数名，通过不同的输入参数来识别。 class student{ public: int num; string name; bool set(int a); bool set(string s); } bool student::set(int a) { num=a; return true; } bool student::set(string s) { name=s; return true; } student a; a.set(10); a.set(&quot;ans&quot;)； ::可以不跟类名，表示全局变量 int month;//全局变量 int day; int year; void Set(int m,int d,int y) { ::year=y; //给全局变量赋值，此处可省略 ::day=d; ::month=m; } Class Tdate { public: void Set(int m,int d,int y) //成员函数 { ::Set(m,d,y); //非成员函数 }//这个相当于在成员函数中执行非成员函数 private: int month; int day; int year; } 类的简单赋值和结构体一样，可以用{} 构造函数：本质上是对类定义的对象进行初始化。 构造函数名要和类名相同。 class student{ public: int num; string name; student(); } student::student() { num=1; name=&quot;zs&quot;; } int main() { student a;//a将会被自动赋值 } 带参数的构造函数 class student{ public: int num; string name; student(); student(int a,string s); } student::student() { num=1; name=&quot;zs&quot;; } student::student(int a,string s) { num=a; name=s; } int main() { student a;//a将会被自动赋值 student b(10,&quot;zs&quot;); } 析构函数 析构函数是运行delete的时候自动调用的函数，销毁内存 student::~student() { cout&lt;&lt;&quot;ok&quot;; } //析构函数写法类似构造函数，但没有输入值，也没有返回值 student a;//这种定义方法，不能用delete调用析构函数 student *p=new student(1,&quot;zs&quot;); delete p;//自动调用析构函数 ","tags":[],"title":"c++面向对象","feature":"","link":"https://s111z.github.io/post/cmian-xiang-dui-xiang/","stats":{"text":"3 min read","time":133000,"words":501,"minutes":3},"date":"2023-10-18 11:41:20","dateFormat":"2023-10-18"},{"content":"Don't Try to Count 题目大意：给定两个字符串，一个x,一个s,我们可以对x进行积累操作（即x += x）,我们需要判断s能否成为x的子串 思路：这道题的思路其实十分简单，就写个循环累加x,每累加一次就进行判断，判否的退出条件就是x的长度大于s的2倍。不过要注意，一定要先累加再判断，累加操作相当于将x的首尾连起来，产生新的顺序，实际上累加一次就不会再出现新的序列了，但是因为s的长度可能远大于x，所以需要累加到s的2倍比较靠谱,（如果仅累加到等长，s可能并不从x的第一个字符开始就跟它匹配）。但是x要是比s长，那么先判断的话就不会进行累加，那就没有新序列，所以要先累加再判断。另外找子串可以用find()，更简单。 find()找子串的代码： //在a中找b if(a.find(b)!=string::npos) printf(&quot;YES&quot;); else printf(&quot;NO&quot;); 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { int n,m; cin&gt;&gt;n&gt;&gt;m; string x,s; cin&gt;&gt;x&gt;&gt;s; if(x.find(s)!=string::npos) //先找一遍，如果找到自然不用再累加 { printf(&quot;0\\n&quot;); continue; } else { x += x; int i=1; while(1)//这里还可以用do-while来写，因为我们要先执行再判断 { if(x.find(s)!=string::npos) { printf(&quot;%d\\n&quot;,i); break; } if(x.size()&gt;2*s.size()) { printf(&quot;-1\\n&quot;); break; } x += x; i++; } } } } do-while写法： #include&lt;bits/stdc++.h&gt; using namepsace std; int main() { int t; cin&gt;&gt;t; while(t--) { int n,m; cin&gt;&gt;n&gt;&gt;m; string x,s; cin&gt;&gt;x&gt;&gt;s; if(x.find(s)!=string::npos) printf(&quot;0\\n&quot;); else { int i=0; do{ i++; x+=x; if(x.find(s)!=string::npos) { printf(&quot;%d\\n&quot;,i); break; } if(x.size()&gt;2*s.size()) { printf(&quot;-1\\n&quot;); break; } }while(1); } } } Three Threadlets 题目大意：给定三个数，我们定义一次划分操作为：将一个数a分成b,c，使得b+c=a；我们对这三个数最多只能进行3次划分操作，问最终能否使它们的全变成相同的数 思路：这道题我们分情况讨论，我们假定三个数分别为x,y,z； 当x=y=z时，一次操作也不用进行； 当x=y!=z时，要分成两种小情况， z大于x,那么要使最后所有的数都一样，我们就要对z进行划分，那么z最后要划分成几个等于x的数，那么z一定要是x的倍数，而且我们简单推理可知，2倍的时候需要划分一次，3倍的时候需要划分两次，4倍的时候需要划分3次，所以z最多只能是x的4倍； z小于x,那么就要将x和y划分成几个z，因为x,y相等，所以对它们的操作数是一样的，因为总操作数不能超过3，所以，x和y只能是z的两倍； x!=y!=z,这种情况，肯定也是最小的不动，因为总共就三刀，最小的一定不能动，否则刀数一定会超。那么就是切另外两个，由情况2推出来的规律可知，切的刀数和倍数有关，那么我们就是说，首先要满足倍数关系，然后y/x+z/x&lt;=4，然后就ok了。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[4]; int main() { int t; cin&gt;&gt;t; while(t--) { scanf(&quot;%d%d%d&quot;,&amp;a[1],&amp;a[2],&amp;a[3]); sort(a+1,a+4);//方便第二种和第三种情况的大小比较 if(a[1]==a[2]&amp;&amp;a[2]==a[3]) printf(&quot;YES\\n&quot;); else if(a[1]==a[2]&amp;&amp;a[2]!=a[3])//两个小的等 { if(a[3]%a[2]==0) { int q=a[3]/a[2]-1; if(q&lt;=3) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else printf(&quot;NO\\n&quot;); } else if(a[1]!=a[2]&amp;&amp;a[2]==a[3]) { if(2*a[1]==a[3]) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else { if(a[2]%a[1]==0&amp;&amp;a[3]%a[1]==0) { int q=a[2]/a[1]+a[3]/a[1]-2; if(q&lt;=3) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else printf(&quot;NO\\n&quot;); } } } Perfect Square 题目大意：给定几个偶数级的矩阵，规定该矩阵顺时针转90度后如果与原矩阵完全相同，就称这个矩阵为合法矩阵，另外规定一次操作是将一个位置上的字母按照字母表顺序变成它后面的一个字母，问要将一个矩阵变成合法矩阵最少需要进行几次操作 思路：这道题一定要注意操作的意义，观察图可发现，因为旋转，所以每四个元素相当于轮换了一次，那么就是说，对应位置的四个元素必须相同，我们将四个位置的元素位置写出来： (x,y)--(y,n-x+1)--(n-x+1,n-y+1)--(n-y+1,x) 就是遍历，然后每次判这四个元素，相不相等，如果相等就不用操作，如果不相等就统计每种字母出现的个数，并找出最大的字母，然后先计算需要多少次操作，再将这四个字母全改成我们找到的最大的字母。 #include&lt;bits/stdc++.h&gt; using namespace std; char s[1010][1010]; int main() { int t; cin&gt;&gt;t; while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%s&quot;,s[i]+1); long long ans=0; for(int x=1;x&lt;=n;x++) { for(int y=1;y&lt;=n;y++) { if(s[x][y]==s[y][n-x+1]&amp;&amp;s[y][n-x+1]==s[n-x+1][n-y+1]&amp;&amp;s[n-x+1][n-y+1]==s[n-y+1][x]) continue; else { map&lt;char,int&gt;mp; mp[s[x][y]]++; mp[s[y][n-x+1]]++; mp[s[n-x+1][n-y+1]]++; mp[s[n-y+1][x]]++; char st; for(auto it:mp) st=it.first; ans += (long long)(st-s[x][y]); ans += (long long)(st-s[y][n-x+1]); ans += (long long)(st-s[n-x+1][n-y+1]); ans += (long long)(st-s[n-y+1][x]); s[x][y]=s[y][n-x+1]=s[n-x+1][n-y+1]=s[n-y+1][x]=st; } } } cout&lt;&lt;ans&lt;&lt;endl; } } Divide and Equalize 题目大意：给定一个长为n的数组，我们每次可以进行如下操作： 挑选两个元素ai,aj； 取ai的一个因数x; ai/=x,aj*=x; 问最后能否使这个数组中所有的元素都相同，如果可以，我们就输出YES，否则输出NO 思路：这道题很巧妙，因为要找因数，所以想到分解质因数，质因数可以凑因数，当对一个合法样例进行分解质因数后可以发现，每个质因子的指数的和是n的倍数,我们取因数可以就取质因数，一个数的质因数少一个，另外的就多一个，然后就全部匀开了。 另外这里进行一个优化，分解质因数的时候，我们不需要从2开始按顺序遍历，即不用模板来写，我们先预处理一个质因数数组，然后遍历这个数组来进行质因数的拆分，这样减少了一些无效访问，会快很多。 #include&lt;bits/stdc++.h&gt; using namespace std; vector&lt;int&gt;p; int st[1000010]; int main() { for (int i = 2; i &lt;= 1000010; i ++ ) { if (!st[i]) p.push_back(i); for (auto it:p) { if(it &gt; 1000010 / i) break; st[it * i] = 1; if (i % it == 0) break; } } int t; cin&gt;&gt;t; while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); map&lt;int,int&gt;mp; for(int i=0;i&lt;n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); int j=0; while(x!=1) { if(x%p[j]==0) { while(x%p[j]==0) { mp[p[j]]++; x/=p[j]; } } else j++; } } int flag=1; for(auto it:mp) { if(it.second%n!=0) { flag=0; break; } } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } Block Sequence 题目大意：给定一个数组a[],我们定义完美数组是：可以将这个数组分成若干块，每一块的第一个数表示个数，后面有这么多个数。我们一次操作可以删除一个数，问至少需要进行多少次操作，才能使数组a变成完美数组。 思路：其实最初的思路是对的，只是没有考虑全面，对一个数，它后面的数字个数如果比它小，那么这个数就需要删掉，但是要考虑后面个数比它大，但是可以不删的情况，所以相当于我们要考虑每个位置删和不删两种情况，从后往前进行递推。这里不好想的就是不删的情况，实际上不删就是要从这里划一块然后我们就要看下一块的开头位置，来计算操作数。 我们定义的d数组表示，如果以当前这个数开头，那么需要删多少个，首先就要考虑这个数被删掉的情况，然后考虑它合法的情况。另外一定要从后往前访问，因为当前如果可以的话，我们就要考虑后面的那一组，所以从后往前更新。 这道题有多种不同的状态，我们要理清楚状态转移的过程，我们讨论的就是是否以某个数开头，如果从前往后访问，那么当前访问的元素，可能被它前面的元素包含进去了，同时我们也无法进行状态的更新，因为这个状态需要通过它前面合法的那种情况更新而来，但我们由当前数的值只能定，它后面可以包含多少个，而不知道它前面可以包含多少个，如果我们从后往前访问，后面的被更新了，我们只用从后面对应的状态来更新当前值即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[200010],d[200010]; int main() { int t; cin&gt;&gt;t; while(t--) { int n; cin&gt;&gt;n; memset(d,0,sizeof d); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); d[n]=1; for(int i=n-1;i&gt;=1;i--) { d[i]=d[i+1]+1; if(a[i]&lt;=n-i)d[i]=min(d[i],d[i+a[i]+1]); } cout&lt;&lt;d[1]&lt;&lt;endl; } } Minimum Maximum Distance 题目大意：给定一张无向图，标记其中的一些节点，然后给定一个数组f[],f[i]表示节点i到最远标记点的距离。我们要求的是f[]中的最小值。 思路：先给出结论，我们先找出距离最远的两个标记点，并求出它们之间的距离d，最小值就是d/2;下面进行证明： 1.为什么要找两标记点的距离以及为什么是d/2: 如图所示，a,b被标记，c,d没有被标记，我们要求的是f[]中的最小值，显然f[d]&lt; f[c],再抽象一点，d在ab的路径上，而c不在，所以我们要找两标记点，因为它们路径上的点才能得到最小值；至于d/2，因为f[i]取的是最大值，所以一定是中间的那个点才能取到最小的。 2.为什么要找最长的标记点路径 如图所示，我们可以看到有三个被标记的点:a,b,c，如果我们取了a,b，可以发现f[d]是d到c的距离，进而我们可以推知，如果我们取的不是最长的，那么这条路径上的点的f[i]甚至不是到a或者到b的，那么取中间得到的距离都不在f[]中，自然无意义。 如此便证明了我们想要的最大值数组中的最小值就是:(标记点间的最大距离d)/2 写到这儿，就有有一个新问题产生，图是无向图，那么我们该如何求标记点间的最大距离，因为我们初始并没有f[],只有一张无向图。 如上图，因为一个点有多条分枝，所以我们从一个点开始搜，无论是dfs还是bfs，都会漏掉，起点不同分支间经过起点可以得到的值，显然这个值要大于从起点开始的最大值，要解决这个问题，我们实际上只用从找到的最远点再搜一遍即可。这样就可以搜到原起点的不同分支。 推广一下，这个搜两遍的方法也可以用来求任意一张无向图中不规定起止点的最大距离。 #include&lt;bits/stdc++.h&gt; using namespace std; int mark[200010],d[200010]; int h[200010],e[400010],ne[400010],idx; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void dfs(int k) { for(int i=h[k];i!=-1;i=ne[i]) { int j=e[i]; if(d[j]==-1)//该点没被访问过。因为是无向图，所以要标记一下 { d[j]=d[k]+1; dfs(j); } } //循环运行结束会自动返回，不需要额外写return } int main() { int t; cin&gt;&gt;t; while(t--) { memset(h,-1,sizeof h); int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;mark[i]); for(int i=1;i&lt;n;i++) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); add(a,b),add(b,a); } memset(d,-1,sizeof d); d[mark[1]]=0; dfs(mark[1]); int mx=0,e; for(int i=1;i&lt;=m;i++) { if(d[mark[i]]&gt;mx) { mx=d[mark[i]]; e=i; } } memset(d,-1,sizeof d); d[e]=0; dfs(e); for(int i=1;i&lt;=m;i++) mx=max(mx,d[mark[i]]); cout&lt;&lt;(mx+1)/2;//这里我们画两个图讨论一下就会发现需要加上1再除2，才能得到我们想要的距离。 } } ","tags":[],"title":"Codeforces Round 903 (Div. 3)","feature":"","link":"https://s111z.github.io/post/codeforces-round-903-div-3/","stats":{"text":"15 min read","time":891000,"words":3437,"minutes":15},"date":"2023-10-14 22:04:21","dateFormat":"2023-10-14"},{"content":"bfs中st数组的意义是标记已经走过的路径，防止走回头路，所以需要st判断是否可以更新 dijkstra中st数组的意义只是标记已经确定过距离的点，防止重复相同的循环，而不是用来判断是否更新 bellman_ford算法中 根本不需要st数组，就是通过不断遍历更新，不需要st判断是否点可以被更新 spfa不过是对bellman-ford的更新进行优化，只把有效更新的点放入优先队列，st的意义只是判断该点是否在集合中，防止重复放入，进行无意义的重复循环，也不需要用来判断是否可以更新 ","tags":[],"title":"bfs与最短路算法中st数组的意义讨论","feature":"","link":"https://s111z.github.io/post/bfs-yu-zui-duan-lu-suan-fa-zhong-st-shu-zu-de-yi-yi-tao-lun/","stats":{"text":"1 min read","time":38000,"words":185,"minutes":1},"date":"2023-10-13 12:17:01","dateFormat":"2023-10-13"},{"content":"queue&lt;&gt;没有迭代器，不能用for(auto t:q)遍历，只能用弹出再加入的方法遍历 ","tags":[],"title":"语法点","feature":"","link":"https://s111z.github.io/post/yu-fa-dian/","stats":{"text":"1 min read","time":7000,"words":30,"minutes":1},"date":"2023-10-12 16:53:22","dateFormat":"2023-10-12"},{"content":" Goals of Victory 题目大意：足球比赛，有n支队伍，两两对战一场，我们定义一个队伍的每场的效率为进球数-对手进球数，总效率为每场效率和，现给出1~n-1个队伍的总效率，要求出第n支队伍的总效率。 思路： 我们可以发现两队对战，如果比分为2：3，那么效率就分别为-1和1， 如果比分为a:b，那么效率就为a-b和b-a,和一定为0，所以可得所有效率的和为0； 那么将已经给出的加起来得到sum，那么ans=0-sum #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); int ans=0; n--; while(n--) { int num; scanf(&quot;%d&quot;,&amp;num); ans += num; } printf(&quot;%d\\n&quot;,0-ans); } } Helmets in Night Light 题目大意：一个村庄除了Pak Chanek还有n个人，有个消息需要通知到所有人，pak可以通知任意多个人，通知每个人的成本为p,第i个人，可以通知ai个人，通知每个人的成本为bi,先要求通知到所有人的最小成本。 思路：首先被选中通知其他人的人，所需要的花费bi一定要小于p,如果不存在这样的bi，就没必要让别人去通知，pak自己通知即可。如果有，就让这些人去通知，最关键的一点就是，通知了第一个人，这个人可以去通知合法的第二个人，要考虑到这一点,并不是所有合法的都由pak来通知，没必要。 #include&lt;bits/stdc++.h&gt; using namespace std; struct cm { int a,b; }s[100010]; bool cmp(cm x,cm y) { return x.b&lt;y.b; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,p; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); for(int i=0;i&lt;n;i++) { int a; scanf(&quot;%d&quot;,&amp;a); s[i].a=a; } int cnt=0;//有cnt个人小于p int tz=0;//这些人总共可以通知多少人 for(int i=0;i&lt;n;i++) { int b; scanf(&quot;%d&quot;,&amp;b); s[i].b=b; if(b&lt;p)cnt++,tz += s[i].a; } sort(s,s+n,cmp); long long ans=0; if(s[0].b&gt;p) { ans = (long long)p*n; } else { ans += (long long)p; int c=1;//已经被通知的人 for(int i=0;i&lt;n;i++) { int a=s[i].a,b=s[i].b;//a是可以通知的人，b是费用 if(b&lt;p) { if(i&lt;c)//说明这个人被通知了 { if(n-c&gt;=a)//如果剩下的多于a { c += a; ans += (long long)a*b; } else { ans += (long long)b*(n-c); c=n; break; } } else//这个其实不会执行，因为每个人至少可以通知一个人，所以每次访问到的合法的bi，对应的这个人是一定已经被通知到的，大不了就是上一个人只传给它 { ans += (long long)p; c++; } } else break; } if(c!=n) { ans += (long long)p*(n-c); } } printf(&quot;%lld\\n&quot;,ans); } } 优化如下: #include&lt;bits/stdc++.h&gt; using namespace std; struct cm { int a,b; }s[100010]; bool cmp(cm x,cm y) { return x.b&lt;y.b; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,p; scanf(&quot;%d%d&quot;,&amp;n,&amp;p); for(int i=0;i&lt;n;i++) { int a; scanf(&quot;%d&quot;,&amp;a); s[i].a=a; } int cnt=0;//有cnt个人小于p int tz=0;//这些人总共可以通知多少人 for(int i=0;i&lt;n;i++) { int b; scanf(&quot;%d&quot;,&amp;b); s[i].b=b; if(b&lt;p)cnt++,tz += s[i].a; } sort(s,s+n,cmp); long long ans=0; if(s[0].b&gt;p) { ans = (long long)p*n; } else { ans += (long long)p; int c=1;//已经被通知的人 for(int i=0;i&lt;n;i++) { int a=s[i].a,b=s[i].b;//a是可以通知的人，b是费用 if(b&lt;p) { if(n-c&gt;=a)//如果剩下的多于a { c += a; ans += (long long)a*b; } else { ans += (long long)b*(n-c); c=n; break; } } else break; } if(c!=n) { ans += (long long)p*(n-c); } } printf(&quot;%lld\\n&quot;,ans); } } Joyboard 题目大意：有个长为n+1的数组a ，我们先从1-m中选一个数放在a[n+1]上，然后a[i]=a[i+1]%i得到数组a，问有多少种选法使数组中只有k类数。 思路：我们多写几个样例可以发现最多只会出现3类数： 1类数：选0 2类数：选[1,n]或者选x属于[n+1,m]，x%n== 0 3类数：选x属于[n+1,m]，同时x%n!=0 因为我们可以发现一旦某一位上为0后，剩下的都为0，所以核心在于0出现的位置如果0出现在n+1上，那么就全为0，如果出现在第n位，那么就是两类数，如果出现在1~(n-1)中，就要看，n与n+1位上的数是否相同，相同就是两类，不同就是三类，如果a[n+1]%n==a[n+1],那么a[n+1]&lt;n，否则就是大于等于(n+1)才能取到。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m,k; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); if(m&gt;n) { int tw=0; if(k==1) printf(&quot;1\\n&quot;); else if(k==2) { tw=m/n+(n-1); printf(&quot;%d\\n&quot;,tw); } else if(k==3) { tw=m/n+(n-1)+1; int res=m+1-tw; printf(&quot;%d\\n&quot;,res); } else printf(&quot;0\\n&quot;); } else if(m==n) { if(k==1) printf(&quot;1\\n&quot;); else if(k==2) printf(&quot;%d\\n&quot;,n); else printf(&quot;0\\n&quot;); } else { if(k==1) printf(&quot;1\\n&quot;); else if(k==2) printf(&quot;%d\\n&quot;,m); else printf(&quot;0\\n&quot;); } } } Effects of Anti Pimples 题目大意：最初所有元素都是白色，现挑出任意个元素，染成黑色，然后将这些元素对应下标的倍数的下标对应的元素染成绿色，然后此种选法的值为黑色和绿色的值的最大值。求出所有选法的最大值的和sum，sum%998244353. 思路：我们可以新开一个数组s[]，来表示，每个值被选到且只选该元素时的最大值，因为后面的会影响前面的，所以我们倒序访问原数组，进行更新。然后组合时，我们可以发现，如果一个数最大，那么这个数会出现在2(n-1)种选择中(该元素一定被选，剩下的有选与不选两种情况)，如果第二大，那么就有2(n-2)种情况，以此类推。 更新s[i]数组时可以加入三个优化： 1.n-i&gt;=i,这个条件如果为真，那么说明i的倍数已经被访问过了，需要比较一下谁更大，否则直接s[i]=a[i]即可 2.访问倍数时只访问质数倍，因为合数倍一定可以去更新某个两个质数倍，所以考虑质数倍即可 3.用线性筛法求出1-n中的质数 另外结果计算引入快速幂求2^() #include&lt;bits/stdc++.h&gt; using namespace std; int a[100010],s[100010]; int st[100010]; const int mod=998244353; int qmi(int a,int b) { int res = 1 % mod, t = a; while (b) { if (b&amp;1) res = (long long)res * t % mod; t = (long long)t * t % mod; b &gt;&gt;= 1; } return res; } bool cmp(int a,int b) { return a&gt;b; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); vector&lt;int&gt;p; //p装奇数 1-100010 for (int i = 2; i &lt;= n; i ++ ) { if (!st[i]) p.push_back(i); for(auto it:p) { if(it&gt;n/i) break; st[it*i] = true; if(i%it==0) break; } } cout&lt;&lt;*p.rbegin(); //cout&lt;&lt;p.size(); int mx=0; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),mx=max(mx,a[i]); s[1]=mx; for(int i=n;i&gt;=2;i--) { if(n-i&gt;=i)//访问过i的倍数,只看奇数倍即可 { s[i]=a[i]; for(auto it:p) { int tp=i*it; if(tp&gt;n) break; else { s[i]=max(s[i],s[tp]); } } } else//没访问过i的倍数 { s[i]=a[i]; } } sort(s+1,s+1+n,cmp); long long ans=0; for(int i=1;i&lt;=n;i++) { ans += (long long)s[i]*qmi(2,n-i); ans %= mod; } cout&lt;&lt;ans; } ","tags":[],"title":"Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round)题解","feature":"","link":"https://s111z.github.io/post/codeforces-round-902-div-2-based-on-compfest-15-final-roundti-jie/","stats":{"text":"10 min read","time":565000,"words":1982,"minutes":10},"date":"2023-10-11 11:22:04","dateFormat":"2023-10-11"},{"content":"From S To T 题目大意：我们现有三个字符串s,t,p，从p中挑选字符插入s中，问最终能否使字符串s和t相同 思路：这道题其实很简单，我们先判断s,t的长度关系，如果s.szie()&gt;t.size(),那么无论怎样都是不成立的，如果s.size()t.size()，只有st，才可以，否则就不可；如果s.size()&lt; t.szie(),那么就要来找需要插入哪些字符，遍历s,t用双指针的思路，用map来存需要插入的字符和数量。 这里提一点细节， int i=0,j=0; while(i&lt;s.szie()&amp;&amp;j&lt;t.size()) { if(s[i]==t[j]) i++,j++; else { mp[t[j]]++; j++; } } if(i&lt;s.size()) { printf(&quot;NO\\n&quot;); //退出 } while(j&lt;t.size()) { mp[t[j]]++; j++; } //后续访问mp 另外记得再定义一个map，统计一下p中的字符 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { map&lt;char,int&gt;mp1,mp2; string a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(a.size()&gt;b.size()) printf(&quot;NO\\n&quot;); else if(a.size()==b.size()) { if(a==b) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else { for(int i=0;i&lt;c.size();i++) { mp1[c[i]]++; } int i=0,j=0; while(i&lt;a.size()&amp;&amp;j&lt;b.size()) { if(a[i]!=b[j]) { mp2[b[j]]++; j++; } else i++,j++; } if(i&lt;a.size()) printf(&quot;NO\\n&quot;); else { while(j&lt;b.size()) { mp2[b[j]]++; j++; } int flag=1; for(auto t:mp2) { if(t.second&gt;mp1[t.first]) { flag=0; break; } } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } } } 3SUM Closure 题目大意：给定一个数组，规定从中任取三个元素a1,a2,a3,如果a1+a2+a3是数组中的元素，那么就称这个数组为3SUM-closed；现给定一个数组，问它是否是3SUM-closed。 思路：我们思考一下可以发现，不能有三个正数或者三个负数同时出现，否则相加就一定会超出范围。我们据此来分类： n3，sum=a1+a2+a3,判断sum是否与某个a相等 n4,求出四个sum，然后判断每个sum是否与某个a相等，要记住，sum与a并非一一对应的关系 n&gt;=5: 因为数组中可以有0，所以这种不是一定不存在； 当全为0时，一定成立； 当有且仅有一个非0数时，一定成立； 当有两个非0数，且两者互为相反数时，一定成立（这个可以通过将数组排序，然后将首末元素相加来判断） 剩下的情况都不成立 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int a[200010]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); if(n==3) { int sum=a[1]+a[2]+a[3],flag=0; for(int i=1;i&lt;=n;i++) { if(sum==a[i]) { flag=1; break; } } if(flag) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else if(n==4) { int sum[5]; sum[1]=a[1]+a[2]+a[3]; sum[2]=a[1]+a[2]+a[4]; sum[3]=a[1]+a[4]+a[3]; sum[4]=a[4]+a[2]+a[3]; sort(a+1,a+1+n); int flag=0; for(int i=1;i&lt;=n;i++)//未必是一一对应 { for(int j=1;j&lt;=n;j++) { if(sum[i]==a[j]) { flag++; break; } } } if(flag==4) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } //全为0，仅一个不为0也可 //两个不为0，且两个互为相反数 //若有3个不为0，那么一定有两正或两负，那么就 else { int flag=0; for(int i=1;i&lt;=n;i++) { if(a[i]==0) { flag++; } } sort(a+1,a+1+n); if(n-flag&lt;=1) { printf(&quot;YES\\n&quot;); } else if(n-flag==2) { if(a[1]+a[n]==0) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else printf(&quot;NO\\n&quot;); } } } Vacations 题目大意：Vasya在假期期间每天可以休息、比赛或健身（三选一），同时规定如下状态： 0表示今天既无比赛，健身房也不开 1表示今天有比赛，但健身房不开 2表示今天无比赛，但健身房开 3表示今天既有比赛，健身房也开 现给出n天的状态，求最少休息几天，另外连续两天不能从事一样的活动，当然休息不算活动； 思路：每天做什么有不同的选择，情况很多，不可能穷举，实际上，这是一道动态规划的题目，我们定义 d[i][j]来表示第i天从事活动j，值表示最小休息天数；然后来看状态的划分， d[i][0]=min(d[i-1][0],d[i-1][1],d[i-1][2])+1; d[i][1]=d[i-1][1]+1;//如果前一天进行了1，那么当天就不可以进行1，必须休息，比如连续的1时 d[i][1]=min(d[i-1][0],d[i][1],d[i-1][2]); d[i][2]=d[i-1][2]+1; d[i][2]=min(d[i-1][0],d[i-1][1],d[i][2]); 另外如果今天的状态是 1：那么d[i][2]=inf; 2：那么d[i][1]=inf; //因为今天是一定不能进行这个的，所以后面不能用这个值来更新状态，所以将其设为正无穷，那么我们取min就一定用不到它们 ans=min(d[n][0],d[n][1],d[n][2]); 其实状态划分最容易错的地方在于当天一定不能进行某个活动时，这个状态怎么表示 另外j可以理解成如果今天想进行活动j的最小休息天数。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int inf=0x3f3f3f3f; int a[120]; int d[120][4]; int smin(int a,int b,int c) { int res=min(a,b); res = min(res,c); return res; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); //0是休息，1是不休息 if(a[i]==0)//今天是0就必须休息 { d[i][0]=smin(d[i-1][0],d[i-1][1],d[i-1][2])+1; d[i][1]=inf; d[i][2]=inf; } else if(a[i]==1) { d[i][2]=inf; //今天当然可以休息 d[i][0]=smin(d[i-1][0],d[i-1][1],d[i-1][2])+1; //今天可以进行1 d[i][1]=d[i-1][1]+1;//前1天竞赛了，今天就必须休息 d[i][1]=smin(d[i][1],d[i-1][0],d[i-1][2]); } else if(a[i]==2) { d[i][1]=inf; d[i][0]=smin(d[i-1][0],d[i-1][1],d[i-1][2])+1; //今天可以进行2 d[i][2]=d[i-1][2]+1;//前1天2了，今天就必须休息 d[i][2]=smin(d[i][2],d[i-1][0],d[i-1][1]); } else { d[i][0]=smin(d[i-1][0],d[i-1][1],d[i-1][2])+1; d[i][1]=d[i-1][1]+1; d[i][1]=smin(d[i][1],d[i-1][0],d[i-1][2]); d[i][2]=d[i-1][2]+1; d[i][2]=smin(d[i][2],d[i-1][0],d[i-1][1]); } } int ans = smin(d[n][0],d[n][1],d[n][2]); cout&lt;&lt;ans; } Diverse Garland 题目大意：有一个花环，有三种颜色的花串起来，我们现在要将一部分花替换成别的颜色的花，要求最后能保证1~n,位置相邻的花，颜色不同，问最少需要修改多少次。 思路：这道题就是暴力，循环访问2~(n-1),判断当前花与两边的颜色是否相同(这里看是否跟它前面的相同即可)，相同就改，最后再特判一下位置1和位置n-1的花的颜色，看看需不需要更改，其实也不用，因为2一定和1不同，判一下最后两个，然后就过了。对了，这道题如果将字母映射成数字，会更简单一点。是否满足3个颜色这个，好像不用考虑，至少在如下更新方法中不用考虑 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; scanf(&quot;%d&quot;,&amp;n); string s; cin&gt;&gt;s; //R1,G2,B3 vector&lt;int&gt;a; for(int i=0;i&lt;s.size();i++) { if(s[i]=='R') a.push_back(1); else if(s[i]=='G') a.push_back(2); else a.push_back(3); } int c=0; for(int i=1;i&lt;=n-2;i++)//访问到倒数第二个字符 { if(a[i]==a[i-1]) { if(a[i-1]==a[i+1]) { if(a[i-1]==1) a[i]=2; else a[i]=a[i-1]-1; } else { a[i]=6-a[i-1]-a[i+1]; } c++; } } if(a[n-2]==a[n-1]) { if(a[n-2]==1) a[n-1]=2; else a[n-1]=a[n-2]-1; c++; } cout&lt;&lt;c&lt;&lt;endl; for(int i=0;i&lt;n;i++) { if(a[i]==1) cout&lt;&lt;&quot;R&quot;; else if(a[i]==2) cout&lt;&lt;&quot;G&quot;; else cout&lt;&lt;&quot;B&quot;; } } Phone Numbers 题目大意：Vasya在整理自己的通话记录，每条记录用如下格式表示： string1 int string2,string3,...(int个) string1表示姓名，int表示当前记录中有多少个号码，后面的字符串表示号码是什么 在记录中，每个人可以有多条记录 需要我们来将其整理一下，保证每个名字只出现一次，然后每个人可以有多个号码，但是如果x是y的后缀，那么就不算x，不同的人号码可以相同。 思路：首先要写一个判两个字符串是否有后缀关系的函数，定义一个字符串数组string s[],用map&lt;string,int&gt;mp来将人名映射成数字，方便用s[]存号码，然后对于已经记录过的人，就遍历它的s[t]看看是否新号码与原号码有后缀关系，如果没有就将其放入，如果有就跳过，对没记录的人，将它记录一下。对了，如果已经放入的号码是新号码的后缀，要将已经放入的那个弹出，然后放入新号码。 #include&lt;bits/stdc++.h&gt; using namespace std; int hz(string s1,string s2) { int res=1; if(s1.size()&lt;=s2.size())//s1更小 { for(int i=s2.size()-1,j=s1.size()-1;j&gt;=0;i--,j--) { if(s2[i]!=s1[j]) { res=0; break; } } if(res) return 1;//是子串 else return 0; } else { for(int i=s2.size()-1,j=s1.size()-1;i&gt;=0;i--,j--)//s2更短 { if(s2[i]!=s1[j]) { res=0; break; } } if(res) return 2;//是子串 else return 0; } return 0; } int main() { int n; map&lt;string,int&gt;mp; vector&lt;string&gt;s[30]; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { string ch; int c; cin&gt;&gt;ch&gt;&gt;c; if(mp.count(ch))//查找这个人,已经有 { auto t=mp[ch]; for(int j=0;j&lt;c;j++) { string num; cin&gt;&gt;num; int flag=0,cnt=0; for(auto it:s[t]) { flag=hz(it,num); if(flag) break; cnt++;//erase()的参数是迭代器，所以要记录该号码出现的位置 } if(flag==0) s[t].push_back(num); else if(flag==1)//it是另一个的后缀 { s[t].erase(s[t].begin()+cnt); s[t].push_back(num); } } } else { mp[ch]=i; auto t=i; for(int j=0;j&lt;c;j++) { string num; cin&gt;&gt;num; int flag=0; int cnt=0; if(s[t].size()) { //是否为后缀不是单向的 for(auto it:s[t]) { flag=hz(it,num); if(flag) break; cnt++; } if(flag==0) s[t].push_back(num); else if(flag==1)//it是另一个的后缀 { s[t].erase(s[t].begin()+cnt); s[t].push_back(num); } } else s[t].push_back(num); } } } cout&lt;&lt;mp.size()&lt;&lt;endl; for(auto it:mp) { int t=it.second; cout&lt;&lt;it.first&lt;&lt;&quot; &quot;; cout&lt;&lt;s[t].size()&lt;&lt;&quot; &quot;; for(auto num:s[t]) { cout&lt;&lt;num&lt;&lt;&quot; &quot;; } cout&lt;&lt;&quot;\\n&quot;; } } Round Corridor 题目大意：一个圆分内外两层，两层之间是相通的，但是每层里面会进行分块，块与块之间是不通的，我们将内层分成n块，外层分成m块，在12点方向始终有墙，按下图来定义(x,y) 现有q个询问，每个询问给出x1,y1,x2,y2四个值，要求判断(x1,y1)与(x2,y2)是否相通。 思路：题目看似复杂实际很简单，我们观察可以发现，如果只看内外重合的墙，就会发现圆被分成大块，大块之间不通，但大块内部相通。所以我们只用找出它们重合的墙，然后判断给定的两个坐标是否在同一个大块内即可。 先看重合的墙： k1*2pi/nk2*2pi/既是重合部分， n/m=k1/k2 要求k1,k2，先求出g=gcd(n,m)，k1=n/g,k2=m/g; k1与k2就是每大块包含的内外最小的块的数量。 用y/k就能判断前小块属于哪个大块，另外要注意，y从1开始，所以yk时应该在第0块，但是直接除就会发现它属于第一大块，那么就先y--，即可解决这个问题。 代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int gcd(int a,int b) { return b?gcd(b,a%b):a; } signed main() { int n,m; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); int g=gcd(n,m); int k1=n/g,k2=m/g; int q; scanf(&quot;%lld&quot;,&amp;q); while(q--) { int x1,y1,x2,y2; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2); y1--,y2--; if(x1==x2)//两坐标在同一层 { if(x1==1) { if(y1/k1==y2/k1) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else { if(y1/k2==y2/k2) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } else//在不同层 { if(x1==1)//x2==2 { if(y1/k1==y2/k2) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } else { if(y1/k2==y2/k1) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } } } } PIN Codes 题目大意：我们规定PIN密码为一个四位数的字符串，每个数都可以从0取到9，现给出n个PIN码，问至少修改多少次能使n个PIN码互不相同。 思路：这也是个很简单的题目，一旦PIN相同就修改，不同就不改，我们用map&lt;string,int&gt;mp来存PIN的个数，然后一旦有相同的写个嵌套循环来修改字符即可。注意一定要先将所有的统计出来，边输入边改会增加修改次数。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); map&lt;string,int&gt;mp; string s[20]; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;s[i]; mp[s[i]]++; } int c=0; for(int i=1;i&lt;=n;i++) { if(mp[s[i]]!=1) { mp[s[i]]--; c++; for(int j=0;j&lt;4;j++) { int flag=0; for(int k=0;k&lt;9;k++) { string tp=s[i]; tp[j]=k+'0'; if(!mp.count(tp)) { s[i]=tp; flag=1; mp[s[i]]++; break; } } if(flag) break; } } } cout&lt;&lt;c&lt;&lt;endl; for(int i=1;i&lt;=n;i++) { cout&lt;&lt;s[i]&lt;&lt;endl; } } } IQ test 题目大意：给定一个数组，找出奇偶性与其他元素不同的元素的下标； 思路：也很简单，定义j来记录奇数的个数，o来记录偶数的个数，另外将每次访问到的奇数和偶数的下标记录一下即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[120]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); int o=0,j=0; map&lt;int,int&gt;mp; for(int i=1;i&lt;=n;i++) { int x; cin&gt;&gt;x; if(x%2) j++,mp[1]=i; else o++,mp[2]=i; } if(j==1) cout&lt;&lt;mp[1]; else cout&lt;&lt;mp[2]; } Twist the Permutation 题目大意：现有一个长为n的数组a[]={1,2,...,n},我们每次挑选一个下标i，将从1到i的数向右循环移动任意次。现给出结果数组，需要求出如何选择以及每个选择移动多少次。 思路：看似复杂，实际是暴力的题目。我们从n开始看，将元素逆着循环复位，同时记录移动次数，然后复位到1即可。实现就是：当前已经复位到k了，未复位的长度为len，查找数组中k的位置，然后k即该元素右移了多少（也即这len长的部分循环移动了多少），将这len长的数组逆着复位。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[2010],c[2010],tmp[2010]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) { int x; cin&gt;&gt;x; c[i]=x; } int k=n,len=n; while(k&gt;1) { //int ti=lower_bound(c+1,c+1+n,k)-c;//k右移ti次 //这个函数只能用于有序数组 int ti; for(int i=1;i&lt;=n;i++) { if(c[i]==k) { ti=i; break; } } if(ti!=k) { a[k]=ti; for(int i=ti,j=len;i&gt;=1;i--,j--) tmp[j]=c[i]; for(int i=1,j=ti+1;j&lt;=len;i++,j++) tmp[i]=c[j]; for(int i=1;i&lt;=len;i++) c[i]=tmp[i]; } else a[k]=0; len--,k--; } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); } } Get an Even String 题目大意，给定一个字符串s，我们规定i为奇数时,si=s(i+1)为合格字符串，现要求出我们至少需要删掉多少个字符，能使s变成合格字符串。 思路：这道题不能单纯找连续字符个个数来解决，我们可以定义一个p[30]，来存每个字母是否已经出现，如果已经出现，然后再出现了这个字母，那么就可以组合成一个合法的小节，最后用s.size()-所有可用的字符数即可(统计要删多少个不方便，那么就反着考虑有多少能够保留)。要注意，如果此字符已经被访问过，且当前能组成小节，那么组好后要将所有的p再赋成0，因为中间即使有其他字符，为了组成小节，也要将它们删掉。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { string s; cin&gt;&gt;s; int p[30]; memset(p,0,sizeof p); int m=0; for(int i=0,j=1;i&lt;s.size();i++,j++) { int t=s[i]-'a'+1; if(p[t]) { m+=2; memset(p,0,sizeof p); } else p[t]=1; } cout&lt;&lt;s.size()-m&lt;&lt;endl; } } ","tags":[],"title":"ACDC14","feature":"","link":"https://s111z.github.io/post/acdc14/","stats":{"text":"21 min read","time":1253000,"words":4405,"minutes":21},"date":"2023-10-11 09:18:25","dateFormat":"2023-10-11"},{"content":"黑盒子 此类问题是输入一个无序数组，在第i个数被输入后，输出第k大的数。 这种问题就是要得到合适的有序排列，每次都排序会超时，就要用别的方法来解决，此文提供三种方法： 1.pbds（平衡树） #include&lt;bits/stdc++.h&gt; #include&lt;bits/extc++.h&gt; using namespace __gnu_pbds; using namespace std; #define pii pair&lt;int,int&gt; //要注意pbds不支持录入重复元素，我们可以用pair&lt;int,int&gt;来实现 tree&lt;pii,null_type,less&lt;pii&gt;,rb_tree_tag,tree_order_statistics_node_update&gt;s; int a[200010],b[200010]; void get(int k) { cout&lt;&lt;(s.find_by_order(k-1))-&gt;first&lt;&lt;endl;//序号从0开始 } int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); int j=1,cnt=0; for(int i=1;i&lt;=n;i++) { s.insert({a[i],i}); while(b[j]==i)//b[j]的值可能重复 { cnt++; get(cnt); j++; } } } 2.multiset 同样可以用multiset来实现，我们定义两个multisets1,s2;保证如果x1属于s1,x2属于s2,一定有x1&lt; x2,然后在查找第k大的数的时候，只要调整两个集合，保证s1.size()==k即可实现第k大的数为*s1.rbegin() #include&lt;bits/stdc++.h&gt; using namespace std; int a[200010],b[200010]; int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); multiset&lt;int&gt;s1,s2; int j=1,cnt=0; for(int i=1;i&lt;=n;i++) { if(s1.size()==0||*s1.rbegin()&gt;=a[i]) s1.insert(a[i]); else s2.insert(a[i]); while(b[j]==i) { cnt++; while(s1.size()&lt;cnt) { s1.insert(*s2.begin()); s2.erase(s2.begin()); } while(s1.size()&gt;cnt) { s2.insert(*s1.rbegin()); s1.erase(--s1.end());//要注意，erase()中的参数是迭代器，但是s.rbegin()不能被直接拿来使用，所以我们用--end()； } cout&lt;&lt;*s1.rbegin()&lt;&lt;endl; j++; } } } 3.priority&lt;int,vector,greater&gt; 优先队列 其实和multiset差不多，但是有一点要注意，优先队列O(1)复杂度只能访问到堆顶元素，所以我们要建一个大根堆和一个小根堆，相当于把multiset中的s1倒序排列 #inlcude&lt;bits/stdc++.h&gt; using namespace std; int a[200010],b[200010]; int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]); priority_queue&lt;int&gt;big;//大根堆，相当于s1 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;small;//小根堆，相当于s2 int cnt=0,j=1; for(int i=1;i&lt;=n;i++) { if(big.size()==0||big.top()&gt;=a[i]) big.push(a[i]); else small.push(a[i]); while(b[j]==i) { cnt++; while(s1.size()&lt;cnt) { s1.push(s2.top()); s2.pop(); } while(s1.size()&gt;cnt) { s2.push(s1.top()); s1.pop(); } cout&lt;&lt;s1.top()&lt;&lt;endl; j++; } } } ","tags":[],"title":"黑盒子问题——在不同断点下查找第k大的数","feature":"","link":"https://s111z.github.io/post/hei-he-zi-wen-ti-zai-bu-tong-duan-dian-xia-cha-zhao-di-k-da-de-shu/","stats":{"text":"4 min read","time":221000,"words":714,"minutes":4},"date":"2023-10-09 14:03:15","dateFormat":"2023-10-09"},{"content":"此类题目一般是给定一个无序的数组，在录入的过程中，不断询问中位数（这是题目本质，当然不同的题目表述的意思不同，不过大体都是这个意思。） 有四种算法 1.定义一个vector&lt;&gt;,每次插入数字前先用upper_bound()或者lower_bound()查找，再用insert（）插入。 vector&lt;int&gt;a; while() { int num; cin&gt;&gt;num; auto it=lower_bound(a.begin(),a.end(),num);//lower_bound()不仅可以用来查vector,也可以用在数组中 a.insert(it,num); } 2.multiset 维护两个multiset的结构s1,s2，两个都是从小到大排的，所以我们只需要将保证s1.size()&gt;s2.size(),s1.size()-s2.size()&lt;=1,同时 \\s2.begin()&gt;= *s1.rbegin();那么s1.rbegin()一定是中位数 multiset&lt;int&gt;s1,s2; while()//录入数组的过程 { cin&gt;&gt;num; if(!s1.size()||num&lt;*s1.rbegin()) s1.insert(num); else s2.insert(num); } while(s1.size()&gt;s2.size()+1) { s2.insert(*s1.rbegin()); s1.erase(--s1.end())//s1.rbegin()不能当作迭代器用在erase中 } while(s1.size()&lt;s2.size()) { s1.insert(*s2.begin()); s2.erase(s2.begin()); } 3.对顶堆 4.平衡树查询第K名 ","tags":[],"title":"无序数组求中位数（O(1)）","feature":"","link":"https://s111z.github.io/post/wu-xu-shu-zu-qiu-zhong-wei-shu-o1/","stats":{"text":"2 min read","time":76000,"words":280,"minutes":2},"date":"2023-10-08 16:02:36","dateFormat":"2023-10-08"},{"content":"关系数据库=存储+事务+SQL 存储：关系数据库的数据结构 事务：关系数据库的算法 SQL：关系数据库操作的描述语言 存储： 哈希表 O(1),支持put/get,不支持范围scan B+树：O(logn),支持put/get,也支持范围scan (平衡二叉树) ","tags":[],"title":"数据库","feature":"","link":"https://s111z.github.io/post/shu-ju-ku/","stats":{"text":"1 min read","time":18000,"words":81,"minutes":1},"date":"2023-10-02 13:22:53","dateFormat":"2023-10-02"},{"content":"ABC三题十分简单，不过多赘述，现着重讨论剩下的题，这三题的简单思路和代码附在最后。 E：Iva &amp; Pav 题目大意：给定一个数组a[],定义f(l,r)=a[l]&amp;a[l+1]&amp;...&amp;a[r]，现给定l,k,需要找到最大的r，使f(l,r)&gt;=k。 思路：我们考虑&amp;，两个数进行&amp;运算时，我们看它们的二进制数对应的数位的数，如果都为1的时候，结果就是1，否则就是0，所以我们将在[l,r]之间的数进行运算时，只要同一个数位上都是1，就取1，否则取0.因为找最大的r所以应该用二分，但是这里check函数如果写每个数直接取&amp;就会超时，所以要引入预处理优化一下。我们用到的优化就是定义p[i][j]来表示从a中1-i的数，第j位上总共有多少个1,这样我们判断时只用循环30个数，即二进制的每一位，然后判断当前区间中第j位上1的个数是否等于区间的数字个数，如果等于就证明，每个数的第j位都是1，那么答案的第j位一定是1，那么答案就可以加上1&lt;&lt;j; #include&lt;bits/stdc++.h&gt; using namespace std; int a[200010],p[200010][40]; int sl,k; int check(int x) { int res=0; for(int i=0;i&lt;31;i++) { if(p[x][i]-p[sl-1][i]==x-sl+1) res += (1&lt;&lt;i); } if(res&gt;=k) return 1; else return 0; } int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;31;j++) { if(a[i]&amp;(1&lt;&lt;j)) p[i][j] = p[i-1][j]+1; else p[i][j]=p[i-1][j]; } } int q; scanf(&quot;%d&quot;,&amp;q); while(q--) { scanf(&quot;%d%d&quot;,&amp;sl,&amp;k); if(a[sl]&lt;k) printf(&quot;-1 &quot;); else{ int l=sl,r=n; while(l&lt;r) { int mid=(l+r+1)/2; if(check(mid)) l=mid; else r=mid-1; } if(check(l)) printf(&quot;%d &quot;,l); else printf(&quot;-1 &quot;); } } printf(&quot;\\n&quot;); } } ","tags":[],"title":"Codeforces Round 900 (Div. 3)题解","feature":"","link":"https://s111z.github.io/post/codeforces-round-900-div-3ti-jie/","stats":{"text":"3 min read","time":153000,"words":543,"minutes":3},"date":"2023-09-27 12:17:08","dateFormat":"2023-09-27"},{"content":"Lucky Tickets 题目大意：a收集了一些序号可以整除3的门票，b将它们都撕成两半了，并且还丢掉一些，a打算把剩下的票两两粘起来，但粘起来的条件是粘好后序号可以整除3.，问最后最多可以得到多少张票。 思路：我们知道能整除3的数的特征就是每一位数的和是3的倍数，我们将所有的票上的数字的数位和都算出来，得到的这些数可以分为3类（按照模3的余数来分）。 由于 a%n+b%n=(a+b)%n 所以我们将余数为1和2的配对，余数为3的自己配对即可。 进一步只用统计3类数的数量即可。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; scanf(&quot;%d&quot;,&amp;n); int x1=0,x2=0,x3=0; for(int i=0;i&lt;n;i++) { string s; cin&gt;&gt;s; int ans=0; for(int j=0;j&lt;s.size();j++) { ans += s[j]-'0'; ans %= 3; } if(ans%3==1) x1++; else if(ans%3==2) x2++; else x3++; } int res = min(x1,x2)+x3/2; cout&lt;&lt;res; } Queries on a String 题目大意：给定一个字符串，同时给出m个询问，对于每个询问，我们给出l,r,k三个数，需要在[l,r]的区间内，将每个字符后移k位，最后移出区间后从前面再放入即可。问经过m的询问后，我们最终的字符串是多少。 思路：很明显这是个模拟题，但是直接写模拟会超时，那么我们就要进行优化： 优化一：当k==len(区间长度)时，相当于没有进行移动，所以我们可以对移动次数进行等效缩小。 优化2：将写循环一个一个移动优化成整块整块移动（对比初末位置可发现，实际上是两整块之间进行移动） 两块分别是[l,l+k-1] [l+k,r] #include&lt;bits/stdc++.h&gt; using namespace std; char s[10010]; char t[10010]; int main() { scanf(&quot;%s&quot;,s+1); int m; scanf(&quot;%d&quot;,&amp;m); while(m--) { int l,r,k; scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); int len=r-l+1; k %= len;//优化移动次数 for(int i=l+k,j=l;i&lt;=r;j++,i++) t[i]=s[j];//将前一块移到后面 for(int i=l,j=r-k+1;j&lt;=r;i++,j++) t[i]=s[j];//将后一块移到前面 for(int i=l;i&lt;=r;i++) s[i]=t[i];//将移动好的赋值给原字符串 } printf(&quot;%s&quot;,s+1); return 0; } Bear and Compressing 题目大意：北极熊有一个长度为q的字符串s，想要压缩这个字符串，我们给定一些规则，每条规则包括两部分a,b,a包含两个字符，b包含一个字符，我们规定当s的前两个字符与任意一条规则中的a相同时，可以将前两个字符压缩为b，否则不可以进行压缩。最后得到字符'a',问s有多少种可能情况。另外由于北极熊比较小，只认识a-f这6个字母，所以s中不会出现这六个字母以外的字母，同时，字符串长度在2-6之间。 思路：这个题最开始我想的是一层层拆分，但很明显情况越讨论越复杂，但我突然注意到，这道题的数据范围很小，6^6=46,656,即字符串最多只有这么多种，那么我们可以直接表示出所有长度为q的字符串，然后判断能不能压缩成a即可。对于压缩规则，我们可以用map&lt;string,string&gt;来存。而讨论所有情况时就类似于数字的排列，dfs即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,q; string s; map&lt;string,string&gt;mp; int ans; void dfs(int k) { if(k==n) { string s1; s1+=s[0]; s1+=s[1]; int i=2; while(mp.count(s1)&amp;&amp;i&lt;n) { s1=mp[s1]; s1 += s[i]; i++; } if(mp.count(s1)) s1 = mp[s1]; if(s1==&quot;a&quot;) ans++; return; } for(char i='a';i&lt;='f';i++) { s += i; dfs(k+1); s.pop_back(); } } int main() { cin&gt;&gt;n&gt;&gt;q; while(q--) { string a,b; cin&gt;&gt;a&gt;&gt;b; mp[a]=b; } dfs(0); cout&lt;&lt;ans; } ps:string后接字符串可以直接s+=ch，但是去掉末尾字符串不能直接s-=ch,可以用s.pop_back(); 判断map的键值中是否存在a，可以用map.count(a)来判断，返回1表示有，返回0表示没有 直接给string赋值，可以覆盖掉原来的字符串 Polo the Penguin and Strings 题目大意：题目给定两个数n,k，问有多少个字符串满足条件： 长度为n 有k个字符不同 相邻两个字符不能相同 如果不存在符合条件的字符那么就输出-1 如果存在输出字典序最小的字符串 思路：首先考虑字典序最小，同时要有k个字符不同，那么我们用且仅用k个字符，那么如果n小于k，一定没有合法的字符串；n==k时，就从a开始按顺序输出字母即可；n&gt;k时，我就在前面用a,b进行交替，最后加上剩下的字符即可。这里特别要注意，k可以取到1，k取到1的时候，意思是有1个字符不同，实际上就是只能有一个字符，有两个字符的时候就不符合有1个字符不同的条件。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;k); if(n&lt;k) printf(&quot;-1&quot;); else { if(k==1) { if(n!=1)printf(&quot;-1&quot;); else printf(&quot;a&quot;); } else { if(n==k) { for(int i=0;i&lt;n;i++) printf(&quot;%c&quot;,'a'+i); } else { int d=n-k+2; for(int i=0;i&lt;d;i++) { if(i%2==0) printf(&quot;a&quot;); else printf(&quot;b&quot;); } for(int i=d,j=2;i&lt;n;i++,j++) { printf(&quot;%c&quot;,'a'+j); } } } } } Paranoid String 题目大意：给定一个二进制序列，有一下两个合并条件: 01-&gt;1 10-&gt;0 要求我们给出[l,r]，使可以根据规则将[l,r]段合并成1个字符，问我们有多少个满足条件的区间。 思路： 当只有1个字符的时，是一定符合要求的 当有两个字符的时候，有两种情况（也可以细分成4种），即两个相同，两个相异，两相同肯定不行，两相异一定可以 当有3个字符的时候： 后两个相异: 101,001,010,110 101-&gt;01-&gt;1 001-&gt;01-&gt;1 010-&gt;10-&gt;0 110-&gt;10-&gt;0 故后两个相异时，倒数第三个是什么都无所谓 后两个相同：100，000，111，011 100-&gt;00 000 111 011-&gt;11 后两个相同无论倒数第三个是什么都不能合并 后两个相异，那么一定可以将3个合并成两个相异的，倒数第四个是什么也就无所谓了 所以我们首先ans=n(每个字符单独一个是可以的)，然后循环，每访问到一个字符，如果与前面相同时，（当前长度-1）就是可以产生的合法区间。 #include&lt;bits/stdc++.h&gt; using namespace std; long long ans; char s[200010]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s); ans=n; for(int i=1;i&lt;n;i++) { if(s[i]!=s[i-1]) ans += i; } printf(&quot;%lld\\n&quot;,ans); } return 0; } WeirdSort 题目大意：给定数组a[]和数组p[],我们只能将a中下标为p[i]和p[i]+1的进行交换，我们可以进行无限次交换，问最终能否使a[]成为非降序排列的数组。 思路1：写一个死循环，每次都遍历判断可以进行交换的是否需要进行交换。最后没有交换时退出，遍历数组a，判断是非为非降序排列。这就有两种实现方式： 实现1(遍历数组p): #include&lt;bits/stdc++.h&gt; using namespace std; int p[200],a[200]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(p,0,sizeof p); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++) { int x; scanf(&quot;%d&quot;,&amp;x); p[x]=1; } while(1) { int flag=0; for(int i=1;i&lt;n;i++) { if(a[i]&gt;a[i+1]&amp;&amp;p[i]) { swap(a[i],a[i+1]); flag=1; } } if(!flag) break; } int flag=0; for(int i=1;i&lt;n;i++) { if(a[i]&gt;a[i+1]) { flag=1; break; } } if(flag) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); } } 实现2(遍历数组a): #include&lt;bits/stdc++.h&gt; using namespace std; int p[200],a[200]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); memset(p,0,sizeof p); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++) { int x; scanf(&quot;%d&quot;,&amp;x); p[i]=x; } while(1) { int flag=0; for(int i=0;i&lt;m;i++) { if(a[p[i]]&gt;a[p[i]+1]) { swap(a[p[i]],a[p[i]+1]); flag=1; } } if(!flag) break; } int flag=0; for(int i=1;i&lt;n;i++) { if(a[i]&gt;a[i+1]) { flag=1; break; } } if(flag) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n&quot;); } } 思路2：我们可以发现可以交换的部分实际上是一段一段的，我们只要找出每一段，因为可以进行无限次排序，那么就可以将这一段排成非降序，最后遍历a，判断是否为非降序即可。特别地，要注意给的p[]未必是按顺序排的，所以我们要对p排一次序。 #include&lt;bits/stdc++.h&gt; using namespace std; int a[200],p[200]; int main() { int t; cin&gt;&gt;t; while(t--) { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;m;i++) { int x; cin&gt;&gt;x; p[i]=x-1; } sort(p,p+m); int l=p[0],r=p[0]+1; for(int i=1;i&lt;m;i++) { if(r!=p[i]) { sort(a+l,a+r+1); l=p[i],r=p[i]+1; } else { r=p[i]+1; } } sort(a+l,a+r+1); int c=a[0],flag=1; for(int i=1;i&lt;n;i++) { if(c&gt;a[i]) { printf(&quot;NO\\n&quot;); flag=0; break; } c=a[i]; } if(flag) printf(&quot;YES\\n&quot;); } } Lucky Permutation Triple 题目大意：定义了排序的概念，长度为n的排列中只能出现0~n-1的元素，同时每个元素只能出现一次。现给定一个n，要求我们给出三个长为n的排列a,b,c,要求满足： a%n+b%n=c%n 如果不存在输出-1。 思路：我们分析可得，可以进行错位来得到排列，例如:n=5: a:0 1 2 3 4 b:4 0 1 2 3 c:4 1 3 0 2 但是要注意到，n为偶数时是不成立的，证明如下： 每个排列的和：suma=sumb=sumc=s=(0+n-1) * n/2=(n-1) * n/2; 因为每一项都满足a%n+b%n=c%n，(a+b)%n=a%n+b%n，所以suma+sumb=sumc (mod n) 2s=s (mod n) s=0 (mod n) 如果s与0同余，那么(n-1)/2一定要是整数，只有n为奇数时满足，故得证。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; scanf(&quot;%d&quot;,&amp;n); if(n%2==0) printf(&quot;-1&quot;); else { for(int i=0;i&lt;n;i++) printf(&quot;%d &quot;,i); printf(&quot;\\n%d &quot;,n-1); for(int i=0;i&lt;n-1;i++) printf(&quot;%d &quot;,i); printf(&quot;\\n%d &quot;,n-1); for(int i=0;i&lt;n-1;i++) { int x=i+(i+1); x %= n; printf(&quot;%d &quot;,x); } } } Christmas Spruce 题目大意：给定一棵树，我们将只有父节点没有子节点的点定义为叶子，我们需要判断给出的树每一个非叶子节点是否有三个及以上的叶子节点。 思路：我们开一个vector(可改用set)来记录所有的父节点，同时将父节点的每个子节点记录一下(用set)，最后遍历父节点数组，判断其中的每个元素对应数组的元素是否大于等于3，对了，还需要注意，一个点有子节点时，需要找到它的父节点，并将其从它的父节点对应的数组中弹出。 #include&lt;bits/stdc++.h&gt; using namespace std; int main() {map&lt;int,int&gt;mp;//键值为子，v为父 vector&lt;int&gt;a;//可改用set int n; scanf(&quot;%d&quot;,&amp;n); set&lt;int&gt;s[1010]; mp[1]=0; for(int i=2;i&lt;=n;i++) { int x; cin&gt;&gt;x; a.push_back(x); s[x].insert(i); mp[i]=x;//将i的父节点标记为x if(s[mp[x]].size()) s[mp[x]].erase(x);//找x的父节点，将x弹出 } for(auto t:a) { if(s[t].size()&gt;=3 ) continue; else { printf(&quot;No&quot;); return 0; } } printf(&quot;Yes&quot;); return 0; } Tiling with Hexagons 题目大意： 如图，我们给定a,b,c，要求六边形个数。 思路：实际上就是找规律，我们竖着看可发现左右个数是对称的，进而找到规律 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int main() { int a,b,c; scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c); int cnt=a; int res=0; for(int i=1;i&lt;=b-1;i++) { res += cnt; cnt++; } res *= 2; c -= (b-1); res += c*cnt; printf(&quot;%lld&quot;,res); } Chess 题目大意：棋盘中，已经有一个车和一个马，两者互不干扰，要求再放一个马，三者互不干扰，问这个马有多少种放法。 思路：我们就从三个角度考虑：首先是，原来车和马的位置一定不可放入，其次新放入的马不能消灭原来的两个棋子，由于马的行走路线是固定的，我们只用根据已知的两个位置判断哪些位置不可以放即可，然后再考虑，原来的棋子不能消灭新放入的马，对于原来的马来说无所谓，新马到它和它到新马是互逆的，考虑一个即可，对于车，只用考虑它的同行列即可。那么我们就可以定义一个set&lt;pair&lt;int,int&gt;&gt;s来装哪些位置不可放入即可，最后用64-s.size()即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int rx[]={-2,-2,2,2,1,1,-1,-1}; int ry[]={1,-1,1,-1,2,-2,2,-2}; int main() { char s1[3],s2[3]; scanf(&quot;%s%s&quot;,s1,s2); pair&lt;int,int&gt;a,b; a={s1[0]-'a'+1,s1[1]-'0'}; b={s2[0]-'a'+1,s2[1]-'0'}; set&lt;pair&lt;int,int&gt;&gt;s; s.insert(a); s.insert(b); for(int i=0;i&lt;8;i++) { int x1,y1,x2,y2; x1=a.first+rx[i]; y1=a.second+ry[i]; x2=b.first+rx[i]; y2=b.second+ry[i]; if(1&lt;=x1&amp;&amp;x1&lt;=8&amp;&amp;1&lt;=y1&amp;&amp;y1&lt;=8) s.insert({x1,y1}); if(1&lt;=x2&amp;&amp;x2&lt;=8&amp;&amp;1&lt;=y2&amp;&amp;y2&lt;=8) s.insert({x2,y2}); } for(int i=1;i&lt;=8;i++) { s.insert({a.first,i}); s.insert({i,a.second}); } cout&lt;&lt;64-s.size(); } ","tags":[],"title":"ACDC13","feature":"","link":"https://s111z.github.io/post/acdc13/","stats":{"text":"18 min read","time":1034000,"words":3724,"minutes":18},"date":"2023-09-26 18:34:17","dateFormat":"2023-09-26"},{"content":"memset的时间复杂度是O(n) #include&lt;bits/stdc++.h&gt; using namespace std; int st[200010]; char a[200010],b[200010]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; scanf(&quot;%d&quot;,&amp;n); //memset(a,0,sizeof a); 这个时间复杂度是O(n),包括下面那一行，所以理论上这两行这么写就会超时，可能因为数据原因所以可以留一个，但实际上没必要，可以在该点被占后，将a[i]的值改变 memset(st,0,sizeof st); scanf(&quot;%s&quot;,a); scanf(&quot;%s&quot;,b); int c=0; for(int i=0;i&lt;n;i++) { if(b[i]=='1') { //这里按照贪心，应该先尽可能的填左边然后填右边 if(i-1&gt;=0&amp;&amp;a[i-1]=='1'&amp;&amp;!st[i-1]) c++,st[i-1]++; else if(a[i]=='0') c++,st[i]++; else if(a[i+1]=='1'&amp;&amp;!st[i+1]) c++,st[i+1]++; } } printf(&quot;%d\\n&quot;,c); } } 冒泡排序原理： 每次将序列中最大的（最小的）移到乱序部分的最后，第一层循环只是表示我们在进行第几次排序，我们实际上访问的下标是第二层循环中的。我们只用进行n-1次排序即可，因为在第二层循环中会访问到j+1，所以我们访问的最后一个是乱序个数减1. 有个特别好记得办法：外层循环从几开始都行，只要保证第一次循环时，内层循环能够访问到数组中倒数第二个数即可。 Double Sort 对于这道题，既然要求我们每次交换时，将a,b中的都交换，并且要输出交换的下标，那么我们直接冒泡排序就好，对a进行一次冒泡排序，b同时进行交换，同时记录交换的下标，再对b进行一次冒泡排序，a同时进行交换，同时记录下交换的下标，最后循环访问a,b，判断是否为满足题目要求的非递减序列，如果是，那么就输出交换的次数和每次交换的下标，否则就输出-1 #include&lt;bits/stdc++.h&gt; using namespace std; int a[200],b[200]; int main() { int t; scanf(&quot;%d&quot;,&amp;t); while(t--) { int n; vector&lt;pair&lt;int,int&gt;&gt;s; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;b[i]); for(int i=0;i&lt;n-1;i++) { for(int j=0;j&lt;n-i-1;j++) { if(a[j+1]&lt;a[j])//递减 { swap(a[j],a[j+1]); swap(b[j],b[j+1]); s.push_back({j,j+1}); } } } for(int i=0;i&lt;n-1;i++) { for(int j=0;j&lt;n-i-1;j++) { if(b[j+1]&lt;b[j])//递减 { swap(b[j],b[j+1]); swap(a[j],a[j+1]); s.push_back({j,j+1}); } } } int flag=1; for(int i=0;i&lt;n-1;i++) { if(a[i+1]&lt;a[i] || b[i+1]&lt;b[i]) { flag=0; break; } } if(flag) { printf(&quot;%d\\n&quot;,s.size()); for(auto it:s) cout&lt;&lt;it.first+1&lt;&lt;&quot; &quot;&lt;&lt;it.second+1&lt;&lt;endl; } else printf(&quot;-1\\n&quot;); s.clear(); } } Replace and Keep Sorted 思路：这道题虽然很像前缀和，但是数组的性质决定了无法使用前缀和，本题的思路是直接从我们可选的数字入手。在1-k中，小于al的可以用来替换al，每替换一个就会多一种可能的数组；大于ar的可以用来替换ar，每替换一个就会多一种可能的数组，剩下的就是在al和ar之间的，这一部分的处理比较特殊，我们找出所有在两者之间同时未在原数组中出现的数，对于每一个数，它只要存在就说明，它在原数组中间部分的某两个数之间，只要满足这个性质，那么它既可以用来替换左边那个数，也可以用来替换右边那个数。所以最后的式子是三部分相加： 1.al-1 2.k-ar 3.2((ar-al+1)-(r-l+1)) #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int t; cin&gt;&gt;t; while(t--) { char s[4]; int c=0; scanf(&quot;%s&quot;,s); if(s[0]!='a') c++; if(s[1]!='b') c++; if(s[2]!='c') c++; if(c==2||c==0) printf(&quot;YES\\n&quot;); else printf(&quot;No\\n&quot;); } } ","tags":[],"title":"ACDC12","feature":"","link":"https://s111z.github.io/post/acdc12/","stats":{"text":"5 min read","time":292000,"words":1066,"minutes":5},"date":"2023-09-20 10:44:14","dateFormat":"2023-09-20"},{"content":"最小生成树 最小生成树是对于一个无向图引出的定义，在一个无向图中有一棵树T，T包含所有的点，同时T中的边也属于该无向图，同时边权和最小。最小生成树没有环 普利姆算法（Prim） 朴素版O(n^2) 稠密图 堆优化O(mlogn) (很少用，效率不如克鲁斯卡尔算法) 克鲁斯卡尔算法（Kruskal） O(mlogm) 稀疏图 二分图 判断是否为二分图 染色法O(n+m) 匈牙利算法 O(mn),一般远小于O(nm) Prim算法 这种算法就是从1开始（实际上可以从任一点开始，侧重点是边，而且每个点都要被放入最小生成树，而且是无向图，所以从哪儿开始都可以），更新每个点的距离，然后找最小距离的点，将这个距离加入res中，然后再用这个点更新其他的点，更新时需要注意，我们想要得到的距离是点到集合的距离，所以我们每次找出的点放进集合后，就是判断这个点到其他点的距离，会不会让其他点到集合的距离更短。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=510,inf=0x3f3f3f3f; int n,m,res; int g[N][N],d[N],st[N]; int Prim() { memset(d,0x3f,sizeof d); //其实定哪个为起点都无所谓，因为最小生成树需要包含所有的点，我们随意定一个点，然后实际用到的是它所有出边里面最短的，每次连一个点，然后下一次循环找目前已经更新过的距离集合最近的点 for(int i=0;i&lt;n;i++) { int t=-1; for(int j=1;j&lt;=n;j++) { if(!st[j]&amp;&amp;(t==-1||d[j]&lt;d[t])) t=j; } // cout&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;d[t]&lt;&lt;endl; if(i&amp;&amp;d[t]==inf) return inf; st[t]=1; if(i) res += d[t]; for(int j=1;j&lt;=n;j++) d[j]=min(d[j],g[t][j]); } } int main() { memset(g,0x3f,sizeof g); cin&gt;&gt;n&gt;&gt;m; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; g[a][b]=g[b][a]=min(g[a][b],c); } int t=Prim(); if(t==inf) printf(&quot;impossible&quot;); else printf(&quot;%d&quot;,res); } Kruskal 这个算法用到了并查集，实现思路是将所有的边按照从小到大的顺序排列，然后访问这些边，用并查集来表示连通块，对于每次访问到的边，判断两个节点是否属于一个并查集，如果不是就将它们连通起来，当然，如果是就意味着它们以更短的边被放进集合中去了，不需要更新。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100010,M=200010; struct edge { int a,b,c; }e[M]; int p[N]; bool cmp(edge a,edge b) { return a.c&lt;b.c; } int find(int a) { if(p[a]!=a) p[a]=find(p[a]); return p[a]; } int n,m; int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;m;i++) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; e[i]={a,b,c}; } sort(e,e+m,cmp); for(int i=1;i&lt;=n;i++) p[i]=i; int res=0,cnt=0; /*用并查集来表示连通块，按照边权排序后，从小到大访问，访问到a,b时，如果两者不属于同一个连通块， 那就将两者连起来，并将当前访问到的边放入最小生成树中*/ for(int i=0;i&lt;m;i++) { int a=e[i].a,b=e[i].b,c=e[i].c; a=find(a),b=find(b); if(a!=b) { p[a]=b; res += c; cnt++; } } if(cnt&lt;n-1) printf(&quot;impossible&quot;); else printf(&quot;%d&quot;,res); } 二分图 二分图定义：一个图中的所有点可以被分进两个集合中去，同一集合中的点不相连，所有的边都在两个集合之间。 二分图性质：一个图是二分图，当且仅当图中不含有奇数环（环中边数为奇数被称为奇数环） 二分图有两个考点： 判断图是否为二分图 求二分图的最大匹配 判断图是否为二分图用的是染色法，原理是对于每个点进行深搜，将每个连通块染色，每个点和与之相连的点染色相反，如果在染色过程中出现矛盾，那么就不是二分图。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; const int N=100010,M=200010;//要注意因为是无向图，所以要建两条边，故而是2倍，如果数组越界，那么什么问题都有可能发生。 int h[N],e[M],ne[M],idx; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int c[N]; int dfs(int v,int color) { c[v]=color; for(int i=h[v];i!=-1;i=ne[i]) { int j=e[i]; if(!c[j]) { if(!dfs(j,3-color)) return 0; } if(c[j]==color) return 0; } return 1; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); while(m--) { int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b),add(b,a); } int flag=1; for(int i=1;i&lt;=n;i++) { if(!c[i]) { if(!dfs(i,1)) { flag=0; break; } } } if(flag) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); } 匈牙利算法 匈牙利算法是用来求二分图的最大匹配的算法，由于二分图的性质，我们可以抽象成两个集合中的元素两两配对，只能是一对一的关系，问最多能配出多少对。 ","tags":[],"title":"最小生成树和二分图","feature":"","link":"https://s111z.github.io/post/er-fen-tu/","stats":{"text":"7 min read","time":360000,"words":1356,"minutes":7},"date":"2023-09-18 12:11:30","dateFormat":"2023-09-18"},{"content":"n表点数，m表边数 两大类情况，四种算法 单源最短路（求一个点到其他所有点的最短距离） 边权都是正的 朴素Dijkstra算法 （O(n^2)） 堆优化版的Dijkstra算法 (O(mlogn)) 有负权边 Bellman-Ford O(nm) SPFA 一般O(m) 最坏O(nm) (如果对经过边数进行限制就不能用SPFA,只能用Bellman-Ford) 多源汇最短路（源指起点，汇指终点，此种题有多次询问，起点终点不定） Floyd算法O(n^3) Dijkstra： 简单来记就是，找最短，定最短，更新 类似bfs，但是bfs的边权都是1，搜的实际上是点属于哪一层，但加上边权后，同层点之间的远近也不同了，所以就要每次遍历找未被放入集合同时距离最近的点' #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; int g[600][600]; int d[600]; bool st[600]; int dijkstra(int k) { memset(d,0x3f,sizeof d); //void *memset(void *ptr, int value, size_t num); //memset的原理是将指定内存区域中的每一个字节都赋上指定的值 //int占4字节，一个字节有8位，最后每一个d[i]就是00111111001111110011111100111111， //转成十进制后就是1061109567,在十六进制下就是0x3f3f3f3f d[k]=0; for(int i=0;i&lt;n;i++)//每次循环只会将一个点放入集合中（这里并未真正定义集合而是用st来标识） { int t=-1; for(int j=1;j&lt;=n;j++)//找不在集合中最近的点 { if(!st[j]&amp;&amp;(t==-1||d[t]&gt;d[j])) t=j; } st[t]=1; if(t==n) break;//访问到n的时候可以break for(int j=1;j&lt;=n;j++)//更新其他点的距离 d[j]=min(d[j],g[t][j]+d[t]);//没有负权边，已经放入集合中的路径一定不会更短，所以不会被更新 } if(d[n]==0x3f3f3f3f) return -1; else return d[n]; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(g,0x3f,sizeof g); while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; g[a][b]=min(g[a][b],c); } cout&lt;&lt;dijkstra(1); } 堆优化的Dijkstra #include&lt;bits/stdc++.h&gt; using namespace std; const int N=150010; #define pii pair&lt;int,int&gt; int n,m; int h[N],e[2*N],ne[2*N],w[2*N],idx; int d[N],st[N]; void add(int a,int b,int c) { e[idx]=b,w[idx]=c,ne[idx]=h[a],h[a]=idx++; } int dijkstra() { //用小根堆优化查找最近距离的过程，所以一定要存下距离和点 memset(d,0x3f,sizeof d); d[1]=0; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;q; q.push({0,1}); while(q.size()) { auto t=q.top(); q.pop(); int v=t.second,dis=t.first; if(st[v]) continue; /*按照d[v]进行排序的，每次访问的一定是距离最短的，所以哪怕堆中有同一个元素的多个距离也无所谓， 这个点被访问到时，一定是按照它最短的距离被访问到的*/ st[v]=1; if(v==n) break; for(int i=h[v];i!=-1;i=ne[i]) { int j=e[i]; if(d[j]&gt;dis+w[i]) { d[j]=dis+w[i]; q.push({d[j],j}); } } } if(d[n]!=0x3f3f3f3f) return d[n]; else return -1; } int main() { memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c); } cout&lt;&lt;dijkstra(); } Bellman_ford 该算法的意义在于处理不经过k条边的最短路，算法的核心是每次循环遍历所有边，每次循环只有部分边会被有效更新，而这部分边刚好符合从1到这些边经过不超过k（第一重循环的自变量）条边。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=510,M=10010; int n,m,k; int d[N],r[N]; struct edge { int a,b,c; }e[M]; void bellman_ford() { memset(d,0x3f,sizeof d); d[1]=0; for(int i=0;i&lt;k;i++) /*每次遍历都是在上一次的基础上更新，最开始第一遍，只有与1相连的点x才会被有效更新， 第二次遍历那些与x相连的点也会被有效更新，而1到它们刚好经历两条边， 所以该算法可以找出经过不超过k条边的最短路*/ { memcpy(r,d,sizeof d); for(int j=0;j&lt;m;j++) { int a=e[j].a,b=e[j].b,c=e[j].c; //cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;endl; d[b]=min(d[b],r[a]+c); } } if(d[n]&gt;0x3f3f3f3f/2) printf(&quot;impossible&quot;); else printf(&quot;%d&quot;,d[n]); } int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; for(int i=0;i&lt;m;i++) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; e[i]={a,b,c}; } bellman_ford(); } SPFA 只要图中没有负环就可以用spfa spfa的算法是在bellman_ford算法的基础上进行优化得到的，优化的点在于，在bellman_ford算法每次循环访问了所有边，但有些边的访问是没有办法进行有效更新的，那么我们引入bfs的思想，定义一个队列，将有效更新的那些点放入队列当中，每次只考虑队列中的那些点，只有这些点才能带来有效更新。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100010; int n,m; int h[N],e[2*N],ne[2*N],w[2*N],idx; int d[N],st[N]; void add(int a,int b,int c) { w[idx]=c,e[idx]=b,ne[idx]=h[a],h[a]=idx++; } void spfa() { memset(d,0x3f,sizeof d); d[1]=0; queue&lt;int&gt;q; q.push(1); st[1]=1; while(q.size()) { auto t=q.front(); q.pop(); st[t]=0; for(int i=h[t];i!=-1;i=ne[i]) { int j=e[i]; if(d[j]&gt;d[t]+w[i])//只要成立就要更新 { d[j]=d[t]+w[i]; if(!st[j])//重复放入没有意义 { q.push(j); st[j]=1; } } } } if(d[n]&gt;0x3f3f3f3f/2) printf(&quot;impossible&quot;); else printf(&quot;%d&quot;,d[n]); } int main() { memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m; while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c); } spfa(); } Floyd 这个算法用来求多源汇最短路，虽然能求出任意两点之间的最短路，但是时间复杂度也较高。O(n^3) 基于动态规划，具体原理有待理解。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=210; int n,m,k; int d[N][N]; int main() { cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; //memset(d,0x3f,sizeof d); for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n;j++) { if(i==j) d[i][j]=0; else d[i][j]=0x3f3f3f3f; } } while(m--) { int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; d[a][b]=min(d[a][b],c); } for(int x=1;x&lt;=n;x++) { for(int y=1;y&lt;=n;y++) { for(int z=1;z&lt;=n;z++) { d[y][z]=min(d[y][z],d[y][x]+d[x][z]);//判断y-&gt;z，经过x会不会使路径变短 } } } while(k--) { int a,b; cin&gt;&gt;a&gt;&gt;b; if(d[a][b]&gt;0x3f3f3f3f/2) printf(&quot;impossible\\n&quot;); else printf(&quot;%d\\n&quot;,d[a][b]); } } ","tags":[],"title":"最短路","feature":"","link":"https://s111z.github.io/post/zui-duan-lu/","stats":{"text":"9 min read","time":494000,"words":1688,"minutes":9},"date":"2023-09-18 12:11:15","dateFormat":"2023-09-18"},{"content":"dfs bfs 树和图的dfs和bfs 其实单纯遍历图的话，两种搜索方式都可以，比如油田问题，两种算法都能写通，因为它们都是遍历整张图，只是对同一节点的遍历顺序可能不一样而已。 dfs和bfs的区别：dfs是沿着一条路尽可能的往深处搜，搜到末端的时候回溯搜另一条路；而bfs则是将每一层都搜完然后去搜下一层。它们都可以遍历图和树 dfs 回溯：当搜索到当前路径的末端时，就要返回上一层，这一过程就被称为回溯。回溯最重要的就是将状态恢复。回溯一定要在一次递归后面。 我们以排列数字题作为例子： 排列数字 思路：就是将每一位上放一个数，记录状态，然后考虑下一位数填什么。这里就两个数组，一个数组来记录某个数是否被用过，另一个数组来记录每一位上放了什么。一定要记得回溯要恢复状态。 #include&lt;bits/stdc++.h&gt; using namespace std; int n; vector&lt;int&gt;a; int st[10]; void dfs(int k) { if(k==n+1) { for(int i=0;i&lt;a.size();i++) { printf(&quot;%d &quot;,a[i]); } printf(&quot;\\n&quot;); } for(int i=1;i&lt;=n;i++) { if(!st[i]) { st[i]=1; a.push_back(i); dfs(k+1); a.pop_back(); st[i]=0; } } } int main() { cin&gt;&gt;n; dfs(1); } 剪枝：所谓剪枝就是在这条路径还没有访问结束的时候，就判断出这条路径一定不合法，进而直接舍掉这条路，进行回溯。 我们以n皇后问题为例： n皇后问题 思路：根据题目可知，每行每列只能放一个棋子，所以我们来讨论每一行的棋子放在哪一列，那么就转化成了排列数字问题，不过这道题还有一个限制条件，就是斜着也不能共线，我们观察可发现，斜着的线根据横纵坐标的关系可分成两类，其中一类，每条斜线上的点的横纵坐标相加结果一定，另一类，每条斜线上的点n-x+y的值相同。所以我们再定义两个数组来标记当前的斜线是否被访问过即可。 #include&lt;bits/stdc++.h&gt; using namespace std; int n; vector&lt;int&gt;a; bool c[10],dg[30],udg[30]; void dfs(int k)//k表示访问第k行 { if(k==n) { for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(a[i]==j) printf(&quot;Q&quot;); else printf(&quot;.&quot;); } printf(&quot;\\n&quot;); } printf(&quot;\\n&quot;); return; } for(int i=0;i&lt;n;i++) { if(!c[i]&amp;&amp;!dg[i+k]&amp;&amp;!udg[n-k+i]) { c[i]=dg[i+k]=udg[n-k+i]=1; a.push_back(i); dfs(k+1); a.pop_back(); c[i]=dg[i+k]=udg[n-k+i]=0; } } } int main() { scanf(&quot;%d&quot;,&amp;n); dfs(0); } n皇后还有一种写法，同时也是dfs的另一种写法，按照这个点放与不放分成两类。这种写法一定要注意条件的判断，否则很容易超时，因为每个点都有两种情况，所以很容易时间复杂度就是2的多少次方了。 #include&lt;bits/stdc++.h&gt; using namespace std; int n; bool row[10],col[10],dg[20],udg[20];//row是行，col是列 char g[10][10]; void dfs(int x,int y,int k) { if(y==n) x++,y=0; if(x==n) { if(k==n) { for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) printf(&quot;%c&quot;,g[i][j]); puts(&quot;&quot;); } puts(&quot;&quot;); } return; } dfs(x,y+1,k); if(!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[x+y]&amp;&amp;!udg[n-x+y]) //这里放要进行判断，这一分支不会始终存在，在一定程度上降低了时间复杂度。 { g[x][y]='Q'; row[x]=col[y]=dg[x+y]=udg[n-x+y]=true; dfs(x,y+1,k+1); row[x]=col[y]=dg[x+y]=udg[n-x+y]=false; g[x][y]='.'; } } int main() { cin&gt;&gt;n; memset(g,'.',sizeof g);//可以这么用 dfs(0,0,0); } BFS bfs就是从一个点开始，一层一层往外搜，将搜到的点放入队列，每个点只被第一个搜到它的点更新，队列中也按照距离从小到大的距离排的，因为距离远的后被搜到，后放入队列。 bfs要注意，如果边权都为正，那么一定是近的点先被放入；一旦有负权，queue中的也可以被更新，st的意义只是防止重复放入queue，减少不必要的访问，而且有负权的情况下，队列中的远近不严格，我们用队列的意义就是将值被更新的存一下，因为它被更新了，就会影响其他点的距离。所以访问顺序严格来说也无所谓，实际上，因为图为有向图，所以就是一直更新到不能更新即可（无负环的情况，有负环就要考虑判断退出的问题） 要想查找某个点的路径，可以记录某个点是由谁更新而来，然后倒推路径。 元素是一层一层被放入的，队列中的元素的层级最多相差1，所以不会存在队列中的元素还能被当前访问到的元素更新，能被更新的都是没被放入的。 其实，bfs的意义就是一层一层的去遍历图，只能表示层级关系，如果边权都是1（或者都相等），那么层级与路径长重合，可将层级视为最短路，但bfs是不能来求最短路的，因为队列中的元素，只有层级有非降序关系，一旦引入边权后，队列中的元素就没有距离的远近关系（可以被别的点更新），但我们每次需要取的是距离最近的点，那么bfs或是说queue就不能用于求边权不为1的最短路。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; int g[120][120],d[120][120]; int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0}; bool st[120][120]; pair&lt;int,int&gt; p[120][120];//pair&lt;int,int&gt;也是一种数据类型，自然可以开数组 void bfs(int x,int y) { queue&lt;pair&lt;int,int&gt;&gt;q; d[x][y]=0; st[x][y]=1; q.push({x,y}); while(q.size()) { auto t=q.front(); q.pop(); for(int i=0;i&lt;4;i++) { x=t.first+dx[i]; y=t.second+dy[i]; if(0&lt;=x&amp;&amp;x&lt;n&amp;&amp;0&lt;=y&amp;&amp;y&lt;m&amp;&amp;!g[x][y]&amp;&amp;!st[x][y])//x,y的坐标得加限定 { d[x][y]=d[t.first][t.second]+1; q.push({x,y}); st[x][y]=1; p[x][y]=t;//想要得到最短路径，只需要记录当前状态是由谁更新而来的即可。 } } } printf(&quot;%d\\n&quot;,d[n-1][m-1]); int i=n-1,j=m-1; while(i||j)//倒着将路径输出，因为我们记录的是当前点是从哪个点走来的，所以只能倒着推路径 { auto t=p[i][j]; printf(&quot;%d %d\\n&quot;,t.first,t.second); i=t.first,j=t.second; } } int main() { cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;m;j++) { cin&gt;&gt;g[i][j]; } } bfs(0,0); } 树和图 树是无环连通图 图分有向图和无向图 有向图的存储：1.邻接矩阵，2.邻接表 邻接矩阵：g[i][j]，有两种存法，如果无边权，那么就用1表示有边，0表示无边，若有边权，那就用这个来存边权。（多用于稠密图，即边多的图） 邻接表：对每个点建立一个单链表。h[]和ne[]都用来存下标，e[]用来存值，其实可用vector，但是数组模拟会更快，但原理差不多。idx这个变量可以视为它存的是边（多用于稀疏图） 遍历： dfs:从一个点开始，走到走不了了回溯，走另一条路，直到将联通的点全部遍历结束。 bfs:从一个点开始，一层往外搜，搜到走不动为止。 无论是深搜还是宽搜，每个点只会被遍历一次。 dfs遍历树： dfs遍历树：首先用邻接表将树存起来，然后开始遍历，对于每个点遍历它可以到的点即可，但是要注意，一般每个点都只遍历一次，多了会超时，所以我们在思考时就要想如何在每个点只遍历一次的情况下完成遍历树需要完成的任务。 这道题按照这个来思考：首先用邻接表来存树，该题是无向图，但由于我们每个点都只遍历一次，有第一个开始遍历的点，所以说我们人为的给了这棵树一个顺序，那么为了使我们给的顺序可以走通，我们就必须将两点之间的一来一回都存上。为了使遍历一次就完成任务，首先我们在这次遍历中需要统计出这个点每个子节点（人为定的顺序）的支路点数（这时就将dfs视为一个可以计数的函数来用），然后还要知道走到它的那条路径上的点数，这里就用n-(子节点支路点数和+1)，因为图中无环（树是连通图，n个点,n-1条边一定无环），且每个点遍历一次，那么在遍历过程中有一个点走到它，那么对它来说，所有可以走到的点，有且仅有一个点是已经被访问过的，这条路就可视作父路，进而就可以算出父路的点数。 #include&lt;bits/stdc++.h&gt; using namespace std; int n; const int N=1e5; int h[N],ne[2*N],e[2*N],idx; bool st[N];//每个点只被访问一次 void add(int a,int b)//只有e数组是用来存值的，剩下都用来存下标，ne[]是下标指下标 { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int ans=N; int dfs(int u) { st[u]=1; int sum=1,res=0; for(int i=h[u];i!=-1;i=ne[i]) { int j=e[i]; if(!st[j]) //每个点只被访问一次，所以只会向下访问 //图中无环（连通图,n-1条边不可能产生环），所以与该点相连的点中，有且仅有走到这个点的点是被访问过的，因为我们一直向下访问 //对于每条支路的点数，我们用s来表示，而从父节点方向出去的就用n-sum(sum的初值为1就是算上了当前点) /*同时因为对于每个点我们都考虑它的子节点的支路和从父节点出去后的路径， 所以我们实际上可以在每个点都访问一次的情况下完成计数*/ { int s=dfs(j); res = max(res,s); sum += s; } } res = max(res,n-sum); ans = min(res,ans); return sum; } int main() { cin&gt;&gt;n; memset(h,-1,sizeof h); int t=n-1; while(t--) { int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b),add(b,a); /*虽然我们仅从一个点出发，而且只向下访问，但是我们除了第一个点被默认为父节点以外， 剩下的点的父子关系未必和题中给的顺序一样，图实际上是无向图，但是我们默认第一个点为父节点， 人为生成了一张有向图，为保证这张有向图上的边合理，所以我们要定义双向的边。*/ } dfs(1); cout&lt;&lt;ans; } bfs遍历树其实也简单，就是将遍历过的点放入队列，一层一层的找就是。 #include&lt;bits/stdc++.h&gt; using namespace std; int n,m; const int N=100010; int h[N],ne[2*N],e[2*N],idx,d[N]; bool st[N]; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int bfs() { memset(d,-1,sizeof d); d[1]=0; queue&lt;int&gt;q; q.push(1); st[1]=1; while(q.size()) { auto t=q.front(); q.pop(); for(int i=h[t];i!=-1;i=ne[i]) { int j=e[i]; if(!st[j]) { d[j]=d[t]+1; st[j]=1; q.push(j); } } } return d[n]; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); while(m--) { int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b);//邻接表不用考虑重边，邻接表会将重边都存入，但是由于每个点只会被访问一次，所以重边也就无所谓了 } cout&lt;&lt;bfs()&lt;&lt;endl; } 拓扑排序:所谓拓扑排序就是在无环的有向图中，如果一个点a可以走到另一个点b,那么a一定要在b的前面，我们的思路就是考虑点的入度，将入度为0的点放入队列，然后遍历它连的点，对于它连的点，因为该点已经被放入，所以我们要将这些点的入度都减1，因为当前点已经被排序，它对后面点的影响可以忽略掉。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100010; int n,m; int h[N],ne[2*N],e[2*N],idx; int r[N],st[N]; queue&lt;int&gt;s; void add(int a,int b) { e[idx]=b,ne[idx]=h[a],h[a]=idx++; } int bfs() { queue&lt;int&gt;q; for(int i=1;i&lt;=n;i++) if(!r[i]) { q.push(i),s.push(i); } while(q.size()) { auto t=q.front(); q.pop(); for(int i=h[t];i!=-1;i=ne[i]) { int j=e[i]; r[j]--; if(r[j]==0) { q.push(j); s.push(j); } } } if(s.size()!=n) return 0; else return 1; } int main() { cin&gt;&gt;n&gt;&gt;m; memset(h,-1,sizeof h); while(m--) { int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b); r[b]++; } if(bfs()) { while(s.size()) { auto t=s.front(); s.pop(); cout&lt;&lt;t&lt;&lt;&quot; &quot;; } } else printf(&quot;-1&quot;); } bfs进阶——八数码问题（数字华容道） 这道题bfs的过程实际上很简单，难点在于状态表示，我们是用一个string来表示状态，对于每一个状态，我们将找出所有它可以更新得到的状态，直到得到我们想要的状态，或者判断我们无法得到最终的状态。难点在于二维的更新，我们将其转化成一维来做。 /*本题就是将一种局面看作是一种状态，同时枚举出能由此状态更新到的状态，用bfs的思路找出最后是否可以得到最终状态*/ #include&lt;bits/stdc++.h&gt; using namespace std; int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0}; int bfs(string s) { queue&lt;string&gt;q; unordered_map&lt;string,int&gt;d;//无序map，用哈希表实现，更快 q.push(s); d[s]=0; string end=&quot;12345678x&quot;; while(q.size()) { auto t=q.front(); q.pop(); if(t==end) return d[t]; int dis=d[t]; auto idx=t.find('x'); int a=idx/3,b=idx%3;//将一维转化成二维中的坐标 for(int i=0;i&lt;4;i++) { int x=a+dx[i],y=b+dy[i];//上下左右移动 if(0&lt;=x&amp;&amp;x&lt;3&amp;&amp;0&lt;=y&amp;&amp;y&lt;3) { swap(t[idx],t[x*3+y]); if(!d.count(t)) { q.push(t); d[t]=dis+1; } swap(t[idx],t[x*3+y]);//得换回去，方便下一次移动 } } } return -1; } int main() { string s; for(int i=0;i&lt;9;i++) { char c; cin&gt;&gt;c;//cin不会录空格 s += c;//string可以直接加字符，但不能直接减字符 } cout&lt;&lt;bfs(s); } ","tags":[],"title":"搜索","feature":"","link":"https://s111z.github.io/post/sou-suo/","stats":{"text":"17 min read","time":980000,"words":3789,"minutes":17},"date":"2023-09-18 12:10:30","dateFormat":"2023-09-18"},{"content":"容斥原理的思想可由韦恩图得来。 这里的s不知可以表示面积，还可以表示包含的元素等。 能被整除的数 比如这个题，问1-n中可以被给定的m个质数整除的数有多少个。 我们可以将每个给定的质数的倍数视为一个集合，那就转化为求所有集合元素的并集。可以通过容斥原理来算。 用一个二进制数来表示，当前考虑那些质数的倍数。我们只用求个数，就可以用n/p，就可以得到,n中有多少个数是p的倍数。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int p[20]; int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=0;i&lt;m;i++) scanf(&quot;%d&quot;,&amp;p[i]); int res=0; for(int i=1;i&lt;1&lt;&lt;m;i++)//i==0那么就是一个都不选，没有讨论的意义 { int t=1,c=0; for(int j=0;j&lt;m;j++) { if(i&gt;&gt;j&amp;1)//判断当前位选不选 { if((long long)t*p[j]&gt;n)//如果大于n了也没有讨论的意义了 { t=-1; break; } t *= p[j]; c++; } } if(t!=-1) { if(c%2) res += n/t; else res -= n/t; } } cout&lt;&lt;res; } ","tags":[],"title":"容斥原理","feature":"","link":"https://s111z.github.io/post/rong-chi-yuan-li/","stats":{"text":"2 min read","time":83000,"words":315,"minutes":2},"date":"2023-09-18 12:10:09","dateFormat":"2023-09-18"},{"content":"Nim游戏 Nim游戏 由上述推导可得出，本题只需要求出每堆石子的异或和即可。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; int res=0; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); res ^= x; } if(res) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); } 台阶Nim游戏 台阶-Nim游戏 思路：这道题只能将石子从当前级拿到下一级，而只有第一级是可以直接拿到地上的，所以我们只考虑奇数级台阶，按照前面Nim游戏的思路，求奇数级台阶上石子的异或和。判断是否为0； #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; scanf(&quot;%d&quot;,&amp;n); int res=0; for(int i=0;i&lt;n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); if(i%2==0) res ^= x; } if(res) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); } 集合-Nim游戏 集合-Nim游戏 #include&lt;bits/stdc++.h&gt; using namespace std; int a[120],f[10010]; int n,m; int sg(int x) { if(f[x]!=-1) return f[x]; set&lt;int&gt;s; for(int i=0;i&lt;n;i++) { if(x&gt;=a[i]) s.insert(sg(x-a[i])); } for(int i=0;;i++) { if(!s.count(i)) return f[x]=i;//s.count(i)在s中查找有没有i这个数 } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;a[i]); scanf(&quot;%d&quot;,&amp;m); int res=0; memset(f,-1,sizeof f); for(int i=0;i&lt;m;i++) { int x; scanf(&quot;%d&quot;,&amp;x); res ^= sg(x); } if(res) cout&lt;&lt;&quot;Yes&quot;; else cout&lt;&lt;&quot;No&quot;; } 拆分Nim游戏 将任意一对石子拆分放进两堆更小的，这两堆只要每堆都小于当前堆即可，剩下条件没有限制。 思路：我们将其拆分sg(x1,x2)=sg(x1)^sg(x2),那就是每次拆完后将拆出的两组异或起来，然后再求sg（）； #include&lt;bits/stdc++.h&gt; using namespace std; int n,f[200]; int sg(int x) { if(f[x]!=-1) return f[x]; set&lt;int&gt;s; for(int i=0;i&lt;x;i++) { for(int j=0;j&lt;=i;j++) s.insert(sg(i)^sg(j)); } for(int i=0;;i++) { if(!s.count(i)) return f[x]=i; } } int main() { scanf(&quot;%d&quot;,&amp;n); int res=0; memset(f,-1,sizeof f); for(int i=0;i&lt;n;i++) { int x; scanf(&quot;%d&quot;,&amp;x); res ^= sg(x); } if(res) printf(&quot;Yes&quot;); else printf(&quot;No&quot;); } ","tags":[],"title":"简单博弈论","feature":"","link":"https://s111z.github.io/post/jian-dan-bo-yi-lun/","stats":{"text":"4 min read","time":180000,"words":577,"minutes":4},"date":"2023-09-18 12:09:43","dateFormat":"2023-09-18"},{"content":"高斯消元解多元一次方程： int gauss() { int c,r;//c表示列，r表示行 for(c=0,r=0;c&lt;n;c++) { int t=r; for(int i=r;i&lt;n;i++)//找出第c列绝对值最大的数在哪一行，当然每次要从有效的第一行开始找 if( fabs(a[i][c]) &gt; fabs(a[t][c]) ) t=i; if(fabs(a[t][c])&lt;eps) continue;//如果当前列，所有的数都等于0那么就直接跳过这一列，有效第一行当然不能变 //t存的是行找到的行，r存的是有效第一行，这个循环访问的是列，循环结束后能将我们找到的行移到有效第一行去 for(int i=c;i&lt;=n;i++) swap(a[t][i],a[r][i]); //将我们此时的有效第一行的第一个有效数字变成1，因为都要进行变化，所以倒序是最好的处理方式 for(int i=n;i&gt;=c;i--) a[r][i] /= a[r][c]; for(itn i=r+1;i&lt;n;i++)//这个循环访问的是有效第一行后面的行 if(fabs(a[i][c]) &gt; eps)//如果当前行的目标列值不为0，那就要将其化为0， for(int j=n;j&gt;=c;j--)//两行之间的倍数为a[i][c]，因为有效第一行的第一个数是1，有效第一行中每个数都要乘上与每行第一个数的倍数再与下面的每行进行消元 a[i][j] -= a[r][j]*a[i][c]; r++;//有效第一行下移 } //如果有效第一行没访问到最后一行，那么就说明没有唯一的解 if(r&lt;n) { for(int i=r;i&lt;n;i++)//左边肯定都是0，那就看右边的常数，如果有非0的，那么就无解 if(fabs(a[i][n])&gt;eps) return 2; return 1;//否则就有无穷多解 } for(int i=n-1;i&gt;=0;i--)//i表示行 for(int j=i+1;j&lt;n;j++)//j表示列 a[i][n] -= a[i][j]*a[j][n]; //a[j][n]表示的是后面那个未知数的解，a[i][j]表示的是那个未知数在当前这一行中的系数 return 0; } 完整代码： #include&lt;bits/stdc++.h&gt; using namespace std; int n; double eps=1e-6; double a[120][120]; void out() { for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=n+1;j++) printf(&quot;%10.2lf &quot;,a[i][j]); printf(&quot;\\n&quot;); } } int gaoss() { int c,r;//c表示列，r表示行 for(c=1,r=1;c&lt;=n;c++) { int t=r; //printf(&quot;r=%d c=%d\\n&quot;,r,c); for(int i=r;i&lt;=n;i++)//遍历行 if(fabs(a[i][c])&gt;fabs(a[t][c])) t=i; //printf(&quot;&quot;); if(fabs(a[t][c])&lt;eps) { //printf(&quot;continue\\n&quot;); continue; } //最大行定，将这个与有效第一行进行交换 for(int i=c;i&lt;=n+1;i++) swap(a[t][i],a[r][i]); //将有效行的目标数化为1 for(int i=n+1;i&gt;=c;i--) a[r][i] /= a[r][c]; for(int i=r+1;i&lt;=n;i++) { if(fabs(a[i][c])&gt;eps) for(int j=n+1;j&gt;=c;j--) { a[i][j] -= a[i][c]*a[r][j]; } } //out(); //printf(&quot;\\n&quot;); r++; } //一旦当前列有一个不为0的数，r一定会增加，那就意味着从r行开始就可能是全为0的 if(r&lt;=n) { for(int i=r;i&lt;=n;i++)//r与r+1? { if(fabs(a[i][n+1])&gt;eps) return 2;//无解 } return 1;//无穷多个解 } else { for(int i=n;i&gt;=1;i--) { for(int j=i+1;j&lt;=n;j++) a[i][n+1] -= a[i][j]*a[j][n+1]; } return 0; } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n+1;j++) scanf(&quot;%lf&quot;,&amp;a[i][j]); int d=gaoss(); if(d==0) { for(int i=1;i&lt;=n;i++) printf(&quot;%.2lf\\n&quot;,a[i][n+1]); } else if(d==1) printf(&quot;Infinite group solutions&quot;); else printf(&quot;No solution&quot;); } ","tags":[],"title":"高斯消元","feature":"","link":"https://s111z.github.io/post/gao-si-xiao-yuan/","stats":{"text":"5 min read","time":276000,"words":943,"minutes":5},"date":"2023-09-18 12:09:15","dateFormat":"2023-09-18"},{"content":"1.当a,b的范围比较小的时候可以预处理出来所有的情况 10万组询问，a,b的范围是2000 c(a,b)=c(a-1,b-1)+c(c-1,b) //从a个苹果中选b个苹果可以分成两类问题，先从a个苹果中挑一个，然后将问题分为两类，一类是包含我们挑出的这个苹果，那么就要从a-1个苹果中挑出b-1个，即c(a-1,b-1);一种是不包含我们挑出的这个苹果，那么就是从a-1个中选b个，即c(a-1,b);把两类情况加起来就是我们想要的结果，也即证明上式。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int m=2010,mod=1e9+7; int c[2010][2010]; void init() { for(int i=0;i&lt;m;i++) for(int j=0;j&lt;=i;j++) if(!j) c[i][j]=1; else c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; } int main() { init(); int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); cout&lt;&lt;c[a][b]&lt;&lt;endl; } } 2.当a,b的范围不支持算出每个c(a,b) 1万组询问，a,b的范围在1e5 要考虑通过公式来求： c(a,b)=a!/(b!(a-b)!) 这里因为涉及到除法，除法取模不能直接取，所以我们要考虑用乘法逆元来解决，由前面数论的知识可知，a mod m时的乘法逆元为，a^(m-2)，这里又可以用快速幂来求，进而可在时间限定内求出答案。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100010; int mod=1e9+7; int f[N],uf[N]; int qmi(int a,int b,int mod) { int res=1; while(b) { if(b&amp;1) res=(long long)res * a%mod; b&gt;&gt;=1; a = (long long) a*a%mod; } return res; } int main() { f[0]=uf[0]=1; for(int i=1;i&lt;=100000;i++) f[i]=(long long)f[i-1]*i%mod; for(int i=1;i&lt;=100000;i++) { uf[i]=(long long)uf[i-1]*qmi(i,mod-2,mod)%mod; } int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); printf(&quot;%d\\n&quot;,(long long)f[a]*uf[b]%mod*uf[a-b]%mod); } } 3.a,b的范围非常大 20组询问，a,b的范围在1e18 卢卡斯定理 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int p; int qmi(int a,int b,int p) { int res=1; while(b) { if(b&amp;1) res = (long long)res *a%p; b &gt;&gt;= 1; a=(long long)a*a%p; } return res; } int c(int a,int b) { int res=1; for(int i=a,j=1;i&gt;=b+1,j&lt;=a-b;i--,j++) { res = (long long)res*i%p; res = (long long)res*qmi(j,p-2,p)%p; } return res; } int lucas(long long a,long long b) { if(a&lt;=p&amp;&amp;b&lt;=p) return c(a,b);//这里如果不将等于的情况包含进去的话，就会出现c(p,p-k),取模后得到的结果就不能满足a&gt;=b,遇到比较特殊的值,比如c(p,1)的时候，就会导致最终结果出问题 return (ll)c(a%p,b%p)*lucas(a/p,b/p)%p; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { long long a,b; cin&gt;&gt;a&gt;&gt;b&gt;&gt;p; cout&lt;&lt;lucas(a,b)&lt;&lt;endl; } } a,b的范围在5000以内，但是不允许取模，那么结果很大，就要考虑高精度。需要用公式来计算。 注意到式子中，既有乘法又要除法，如果既要高精度乘法又要高精度除法，但是这样时间复杂度就高了，所以我们可以考虑分解质因数，然后只用高精度乘法。 然后这个问题就通过两步解决了（1.分解质因数，2.高精度乘法） #include&lt;bits/stdc++.h&gt; using namespace std; const int n=5010; vector&lt;int&gt;p; int st[n]; int sum[n]; void Prime() { for(int i=2;i&lt;=n;i++) { if(!st[i]) p.push_back(i); for(auto t:p) { if(t&gt;n/i) break; st[t*i]++; if(i%t==0) break; } } } int get(int a,int t) { int res=0; while(a) { res += a/t; a /= t; } return res; } vector&lt;int&gt;mul(vector&lt;int&gt;a,int b) { int jw=0; vector&lt;int&gt;c; for(int i=0;i&lt;a.size();i++) { jw=a[i]*b+jw; c.push_back(jw%10); jw /= 10; } while(jw) { c.push_back(jw%10); jw /= 10; } return c; } int main() { int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); //筛素数 Prime(); //分解质因数 int cnt=0; for(auto t:p) { sum[cnt]=get(a,t)-get(b,t)-get(a-b,t); cnt++;//这里要记得更新 } //质因数相乘 vector&lt;int&gt;res; res.push_back(1); for(int i=0;i&lt;cnt;i++) { for(int j=0;j&lt;sum[i];j++) { res=mul(res,p[i]); } } //输出结果 for(int i=res.size()-1;i&gt;=0;i--) printf(&quot;%d&quot;,res[i]); return 0; } 卡特兰数 满足条件的01序列 c(2n,n)-c(2n,n-1) 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int mod=1e9+7; int qmi(int a,int b,int p) { int res=1; while(b) { if(b&amp;1) res = (long long)res *a%p; b&gt;&gt;=1; a=(long long)a*a%p; } return res; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); int res=1; for(int i=2*n,j=1;j&lt;=n;j++,i--) { res = (long long)res * i %mod; res = (long long)res * qmi(j,mod-2,mod)%mod; } res = (long long)res *qmi(n+1,mod-2,mod)%mod; cout&lt;&lt;res; } ","tags":[],"title":"组合计数","feature":"","link":"https://s111z.github.io/post/zu-he-ji-shu/","stats":{"text":"7 min read","time":392000,"words":1270,"minutes":7},"date":"2023-09-18 12:08:50","dateFormat":"2023-09-18"},{"content":"质数 定义：在大于1的整数中，因数只包含1和本身的数叫质数 判质数 1.试除法 最朴素的做法：直接暴力循环 //判断n是否是质数 int flag=1; for(int i=2;i&lt;n;i++) { if(n%i==0) { flag=0; break; } } if(flag) printf(&quot;yes&quot;); else printf(&quot;no&quot;); 优化：因数是成对出现的，所以循环到i * i &lt; n即可，但是i&gt;=1e5的时候，i * i就有溢出风险，所以我们用 i&lt;n/i 作为判断条件，这样绝对不hi溢出。 代码： for(int i=2;i&lt;=n/i;i++) { if(n%i==0) { flag=0; break; } } if(flag) printf(&quot;yes&quot;); else printf(&quot;no&quot;); 2.分解质因数 朴素思路：循环，当遇上可以被n整除的数的时候，就用n不断的除掉它，然后记录除的次数即可。 代码： for(int i=2;i&lt;=n;i++) { int s=0; while(n%i==0) { s++; n /= i; } printf(&quot;%d %d&quot;,i,s); } 优化：有一个定理，数n最多有一个大于更号n的质因数，所以可以简化我们的循环 for(int i=2;i&lt;n/i;i++) { int s=0; while(n%i==0) { n/=i; s++; } printf(&quot;%d %d&quot;,i,s); } if(n) printf(&quot;%d 1&quot;,n); 筛法求质数 思路：循环，对于每一个访问到的数，删掉它的整数倍，最后剩下的数就是质数 代码： int st[]; vector&lt;int&gt;p; for(int i=2;i&lt;=n;i++) { if(!st[i]) p.push_back(i); for(int j=i+1;j&lt;=n;j+=i) st[j]=1; } 优化：不用删除所有数的整数倍，只用删掉质数的整数倍即可。（埃氏筛法） 时间复杂度O(nloglogn) 代码： int st[]; vector&lt;int&gt;p; for(int i=2;i&lt;=n;i++) { if(!st[i]) { p.push_back(i); for(int j=i+1;j&lt;=n;j+=i) st[j]=1; } } 质数定理：1到n当中有(n/ln(n))个质数 线性筛法：原理一个合数有且只有一个最小质因数，我们就用这个最小质因数来筛掉它，这样就能保证每个数只被筛一次，就满足了线性的要求 for(int i=2;i&lt;=n;i++) { if(!st[i]) p.push_back(i); for(auto t:p) { if(t&gt;n/i) break; //用t*i来筛数，所以要满足这个条件，否则得到的数就要超过n的范围 st[t*i]++; if(i%t==0) break; //如果t比i的最小质因数还大，那么例如i=4,t=3,那么12就会被筛掉，但实际上i=6,t=2时12会被筛掉，这样12就被筛了两次，不符合线性 //这种算法的原理是一个数只会被它的最小质因数筛掉，一个合数一定有且仅有最小质因数，这样每个数只被筛一次，就符合线性的要求 } } 约数 1.求一个数的所有约数 就用试除法，循环来实现，优化就是i&lt;=n/i for(int i=1;i&lt;=n/i;i++) { if(n%i==0) { p.push_back(i); if(n/i!=i) push_back(n/i); } } 2.求约数个数（int范围内，约数最多的一个数有1500个约数） 原理：利用分解质因数的原理来考虑，N=a1^k1 * a2^k2 * ... * an^kn 约数的个数cnt=(k1+1) * (k2+1) * ... * (kn+1)//就是选几个的问题 3.求约数的和 原理：跟求约数的个数的原理类似，不过求解的式子有变化(a10+a11+...+a1k1)(...)(an0+an1+...+ankn),将式子展开就能得到每个约数相加（对于每个括号内的可以用秦九韶来优化） 4.求两个数的最大公约数（辗转相除法）（对于多个数就两两求） 时间复杂度O(logn) gcd(a,b)=gcd(b,a mod b) 欧拉函数 欧拉函数：1-n中，与n互质（两个数的最大公约数是1）的数的个数 公式：f(n)=n(1-1/a1)(1-1/a2)...(1-1/an)(a是n的质因数) 计算原理是容斥原理： 给定n个数，求每个数的欧拉函数，时间复杂度O(n * sqrt(ai)) #include&lt;bits/stdc++.h&gt; using namespace std; int main() { int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { int a; scanf(&quot;%d&quot;,&amp;a); int res=a; for(int i=2;i&lt;=a/i;i++) { if(a%i==0) { res=res/i*(i-1);//如果先乘可能会爆int while(a%i==0) a /= i; } } if(a&gt;1) res = res/a*(a-1); printf(&quot;%d\\n&quot;,res); } } 筛法求欧拉函数 这里我们求的是1-n中每个数欧拉函数个数的和，求每个数的欧拉函数时，我们用到了线性筛法的原理 先来看线性筛法的模板 for(int i=2;i&lt;=n;i++) { if(!st[i]) p.push_back(i); for(auto t:p) { if(t&gt;n/i) break; st[i*t]++; if(i%t==0) break;//t再大就不能控制t是将要筛掉的数的最小质因数了，也就不能保证算法是线性的了 } } 在式子中，我们想要求每个数的欧拉函数，可发现每次循环最多可以访问到3类数， 第一类数：质数，质数p的欧拉函数是[1,p-1]； 第二类数，合数：合数又分两种： 一种是i%t0时的合数： t * i的质因子由t的质因子和i的质因子构成，t的质因子只有本身，i%t0时，我们考虑i的质因数就已经把t考虑进去了，所以： 另一种是i%t!=0时的合数： 同样t * i的质因子是由t的质因子和i的质因子构成的，t的质因子只有本身，这里t不是i的质因子，所以要额外增加一个t，即： 那么对于每次循环能访问到的数，我们就将其欧拉函数算出来了，按照线性筛法的原理，我们这里的计算也是线性的。代码如下： #include&lt;bits/stdc++.h&gt; using namespace std; int st[1000010],o[1000010]; vector&lt;int&gt;p; int main() { int n; scanf(&quot;%d&quot;,&amp;n); o[1]=1; for(int i=2;i&lt;=n;i++) { if(!st[i]) { p.push_back(i); o[i]=i-1; } for(auto t:p) { if(t&gt;n/i) break; st[i*t]++; if(i%t==0) { o[i*t]=t*o[i]; break; } else { o[i*t]=o[i]*(t-1); } } } long long res=0; for(int i=1;i&lt;=n;i++) res += o[i]; cout&lt;&lt;res; } 欧拉定理、费马小定理及证明： 快速幂 求a的b次方mod p的结果。 #include&lt;bits/stdc++.h&gt; using namespace std; int qmi(int a,int b,int p) { int res=1; while(b) { if(b&amp;1) res = (long long)res*a%p; b &gt;&gt;= 1; a = (long long)a*a%p; } return res; } int main() { int n; scanf(&quot;%d&quot;,&amp;n); while(n--) { int a,b,p; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;p); cout&lt;&lt;qmi(a,b,p)&lt;&lt;endl; } } res = (long long)res * a%p;先将res转成longlong类型，然后再乘上a,防止溢出，但是右边计算后的结果是int范围内的，再将它赋值给int是没有影响的 扩展欧几里得算法 中国剩余定理 ","tags":[],"title":"数论","feature":"","link":"https://s111z.github.io/post/shu-lun/","stats":{"text":"8 min read","time":461000,"words":1726,"minutes":8},"date":"2023-09-18 12:08:28","dateFormat":"2023-09-18"},{"content":"计数问题 题目概括：给定两个数a,b，求[a,b]之间[0,9]出现的次数。（当然a,b不确定大小关系,为方便表述这么写，写题的时候记得处理一下就好） 思路:先求出[1,a]和[1,b]中每个数出现的次数，然后相减即可，类似前缀和的思路。那我们现在就转化成求[1,x]中数字k出现的次数。 状态表示：定义一个数组f[i][j]表示从1到i中j出现的次数 状态计算：求出每一位上数字j出现的次数累加即可。 我们要先进行分类，考虑一般情况，所选取的数位在这个数的中间部分（将所选的数位用t表示），abctdef,我们考虑t位是j的情况，那么相当于定了一位，讨论剩下位上数字的所有可能。我们可以按照t前面数来分类，分成两类： 第一类：000-(abc-1):这一类前面的数字一共有abc种组合，而且可以保证最终的数是一定小于i的，那么t位后面的数字就可以从0-9随便填，t位后面的位数：就是t-1位，那这一类的总情况就是abc * 10^(t-1); 第二类：abc:这一类前面的数已经定了，就要按照第t位上的数再进行分类，当第t位上的数小于我们当前想要查找的数时，是不可能成立的因为，当t位放上我们想要查找的数后，不管怎么组合得到的数一定是大于给定的数的，也即一定大于i；当第t位上的数等于我们想要查找的数时，后面数的上限就是def,因为可从000开始，那么一共就是def+1种组合；当第t位上的数字大于我们想要查找的数时，第t位一旦放上我们想要查找的数后，后面怎么放都可以，也就时10^(t-1)种情况。 特殊情况讨论： 当讨论的数j为0的时候，前面就不能从000开始，所以第一种情况就是(abc-1) * 10^(t-1) 当我们讨论到最左端的数时，前面的数是0，第t位（当前讨论的位）就不能为0 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int count(int x,int k) { int len=0,t=x,res=0; while(t) { len++; t /= 10; } for(int i=1;i&lt;=len;i++)//这个循环每一重就是统计每一位上k出现的次数 { int p=pow(10,i-1),l=x/p/10,r=x%p,nw=x/p%10; //统计k出现的次数 //l在(000,abc-1)之间,(000,abc-1)一共l个数，每个数对应的第i位后面都可以任意排 //这里就是假设第i位上的数字为k，然后讨论其他位上的数字共有多少种组合 if(k) res += l*p; if(!k&amp;&amp;l) res += (l-1)*p; //这里讨论就是当前位的数字已经确定，如果当前位的数字大于k的时候，那我们将当前位的数字定为k，后面位上可以任意放 if((nw&gt;k)&amp;&amp;(l||k)) res += p; //l为0就意味着当前讨论的数为第一个数，当然不能为0，还有别的写法，但显然这样写最简单 //这里讨论就是当前位上数字已经确定，如果当前位的数字等于k的时候，那我们将当前位上的数字定义为k,后面位上的数字就有了一个范围限定 if((k==nw)&amp;&amp;(l||k)) res += r+1; } return res; } int main() { int a,b; while(~scanf(&quot;%d%d&quot;,&amp;a,&amp;b)) { if(!a&amp;&amp;!b) break; if(a&lt;b) swap(a,b); for(int i=0;i&lt;=9;i++) cout&lt;&lt;count(a,i)-count(b-1,i)&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; } } ","tags":[],"title":"数位统计dp","feature":"","link":"https://s111z.github.io/post/shu-wei-tong-ji-dp/","stats":{"text":"4 min read","time":236000,"words":985,"minutes":4},"date":"2023-09-18 12:08:04","dateFormat":"2023-09-18"},{"content":"滑雪 这道题对于每个位置只能滑向更低的位置。 状态表示：用f[i][j]来表示从（i，j）位置出发的所有路径，值表示路径和的最大值。 状态计算：通过四个方向的最大值+1计算得到。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0}; int f[400][400],a[400][400]; int n,m; int dp(int x,int y) { if(f[x][y]!=-1) return f[x][y]; f[x][y]=1; for(int i=0;i&lt;4;i++) { int nx=x+dx[i],ny=y+dy[i]; if(1&lt;=nx&amp;&amp;nx&lt;=n&amp;&amp;1&lt;=ny&amp;&amp;ny&lt;=m&amp;&amp;a[nx][ny]&lt;a[x][y]) { f[x][y]=max(f[x][y],dp(nx,ny)+1); } } return f[x][y]; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); memset(f,-1,sizeof f); int res=0; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { res=max(dp(i,j),res); } } printf(&quot;%d&quot;,res); } ","tags":[],"title":"记忆化搜索","feature":"","link":"https://s111z.github.io/post/ji-yi-hua-sou-suo/","stats":{"text":"2 min read","time":83000,"words":254,"minutes":2},"date":"2023-09-18 12:07:41","dateFormat":"2023-09-18"},{"content":"没有上司的舞会 关键：每个人不能与直属上级一起工作 思路： 状态表示：定义一个二维数组f[i][2],第一维表示第i个节点，第二维,0表示第i个节点不选，1表示第i个节点选，数组的值用来存当前的最大幸福度。 状态计算：当前节点没选时，她的下级选与不选都可，我们找出最大值即可，那么就是 f[i][0]=sum(max(f[j][0],f[j][1]))(j是i的子节点) 当前节点选的时候，其子节点一定不能选f[i][1]=sum(f[j][0]); 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int a[7000],f[7000][2]; vector&lt;int&gt;d[7000]; int n; bool hb[7000]; void dfs(int k) { f[k][1] = a[k];//当这个点被选时，首先要加上它本身 for(auto it:d[k]) { dfs(it);//处理子节点 f[k][0] += max(f[it][0],f[it][1]);//dp f[k][1] += f[it][0];//dp } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;n;i++) { int l,k; scanf(&quot;%d%d&quot;,&amp;l,&amp;k); d[k].push_back(l);//将l放进k中，相当于建立邻接表 hb[l]=true;//这步标记l已经有父节点了 } int root=1; while(hb[root]!=false) root++;//找根节点 dfs(root); printf(&quot;%d&quot;,max(f[root][0],f[root][1])); } ","tags":[],"title":"树形dp","feature":"","link":"https://s111z.github.io/post/shu-xing-dp/","stats":{"text":"2 min read","time":96000,"words":342,"minutes":2},"date":"2023-09-18 12:07:16","dateFormat":"2023-09-18"},{"content":"这类问题一般定义两维，其中一位用二进制数来表示选法或是说方案（当然如果输出当然还是十进制数，我们将之视为二进制数来处理），这类问题需要大量用到位运算。 蒙得里安的梦想 给定一个n * m的矩形，将1 * 2的小长方形放入，问有多少种放法。 思路：我们可以发现，如果先放所有可以横着放的小矩形，那么竖着放的小矩形只有唯一一种放法。所以我们就只讨论可以横着放的矩形。 状态表示：定义一个二维数组f[i][j],i用来表示列数，j用来表示第j行是否有从i-1列伸出来的小矩形。 状态计算：我们还是看倒数第二步，也就是从i-2伸到i-1列的矩形数量，对于第i列的每种情况，就是将与之匹配合法的所有i-1列的情况加起来即可。因为每一种情况可视为一种分类，这种分类内部的不同类加起来即可。 判断合法：这里判断合法要考虑的条件一个就是如果某一行已经从i-2列伸到i-1列，那么就不能再从i-1列伸到i列，另一个则是每列空出来的连续部分不能是奇数，因为竖着放需要占两个格子。因为我们是用二进制数来表示每一位是否有伸出，所以我们可以对所有可能出现的二进制数进行统计，判断是否有连续偶数个0。至于第一个条件的判断就两个数取与（&amp;），只有同时都有的情况下才是非0的，同时都有也就不符合要求了。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int N=12; long long f[12][5000];//方案数可能会很多 bool st[5000]; int main() { int n,m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)) { if(!n&amp;&amp;!m) break; memset(f,0,sizeof f); for(int i=0;i&lt;1&lt;&lt;n;i++) { int c=0; st[i]=true; for(int j=0;j&lt;n;j++) { if(i&gt;&gt;j &amp; 1) { if(c &amp; 1) st[i]=false; c=0; } else c++; } if(c&amp;1) st[i]=false; } f[0][0]=1;//第0列的一个都没有的方案为1 for(int i=1;i&lt;=m;i++)//列的范围是[0,m-1],因为我们要考虑后一列情况，所以从1开始 { for(int j=0;j&lt;1&lt;&lt;n;j++) { for(int k=0;k&lt;1&lt;&lt;n;k++) { if((j&amp;k) == 0)//位运算的优先级小于逻辑运算 { if(st[j|k]) { f[i][j] += f[i-1][k]; } } } } } printf(&quot;%lld\\n&quot;,f[m][0]);//第m-1列没有伸出去的就是最终方案，因为是累加得到的 } } 最短Hamilton路径 思路： 状态表示：定义一个数组f[i][j],用i作为一个二进制数来表示已经走过了哪些点，j表示走到j点时。 状态计算：划分时按照，从哪个点走到j来划分，f[i][j]=f[{i}-j][k]+a[k][j]; 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int a[30][30],f[1&lt;&lt;20][30]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { scanf(&quot;%d&quot;,&amp;a[i][j]); } } memset(f,0x3f,sizeof f); f[1][0]=0;// for(int i=1;i&lt;1&lt;&lt;n;i++) { for(int j=0;j&lt;n;j++) { if((i&gt;&gt;j) &amp; 1)//i表示的走法经过j { for(int k=0;k&lt;n;k++) { if( (i-(1&lt;&lt;j))&gt;&gt;k &amp; 1 )//刨去j点后的路径经过k f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+a[k][j]);//算术运算符的优先级高于位运算符 } } } } cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]; } ps:1&lt;&lt;n,表示1从第1位左移n位，即移到n+1位 ","tags":[],"title":"状态压缩dp","feature":"","link":"https://s111z.github.io/post/zhuang-tai-ya-suo-dp/","stats":{"text":"5 min read","time":256000,"words":977,"minutes":5},"date":"2023-09-18 12:06:53","dateFormat":"2023-09-18"},{"content":"压位其实与高精度的计算方法一样，只是将若干位并在一起作为一个数，这样的话会使运行时间缩短 ","tags":[],"title":"高精度压位","feature":"","link":"https://s111z.github.io/post/gao-jing-du-ya-wei/","stats":{"text":"1 min read","time":8000,"words":42,"minutes":1},"date":"2023-09-18 12:06:28","dateFormat":"2023-09-18"},{"content":"整数划分 给定的数n，n=a1+a2+...+ak,a1&gt;=a2&gt;=a3&gt;=...&gt;=ak,求合法的划分方案数 思路1：将该类问题转化成完全背包问题，不同的地方在于，完全背包问题是求两种转移方式的最大值，f[j]存的是体积不超过j的最大价值，而我们这里是对两种转移方式求和，f[j]存的是和不超过j的选择方式。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int f[1010],mod=1e9+7; int main() { int n; scanf(&quot;%d&quot;,&amp;n); f[0]=1;//当n=0的时候选择方案是1 for(int i=1;i&lt;=n;i++) { for(int j=i;j&lt;=n;j++) { f[j]=(f[j]+f[j-i])%mod; } } cout&lt;&lt;f[n]; } 思路2： 状态表示：用f[i][j]表示总和为i，个数为j的方案，f[i][j]的值表示数量 状态计算：这里的划分比较巧妙，按照每种方案中1的选与不选来划分(这样可以保证不重不漏)，如果选1，那么就将所有的方案都去掉一个1，那么就得到f[i-1][j-1],如果不选1，那就将方案中所有的数都减去一个1，就得到f[i-j][j]，将两者加起来就得到f[i][j].在得到最后答案时要注意，我们的第二维是个数，所以求最后的答案要把f[n][i]加起来. 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int f[1010][1010],mod=1e9+7; int main() { int n; scanf(&quot;%d&quot;,&amp;n); //当n=0的时候选择方案是1 f[0][0]=1; for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=i;j++) { f[i][j]=(f[i-1][j-1]+f[i-j][j])%mod; } } int res=0; for(int i=1;i&lt;=n;i++) res = (res+f[n][i])%mod; cout&lt;&lt;res; } ","tags":[],"title":"计数类dp","feature":"","link":"https://s111z.github.io/post/ji-shu-lei-dp/","stats":{"text":"3 min read","time":124000,"words":458,"minutes":3},"date":"2023-09-18 12:06:07","dateFormat":"2023-09-18"},{"content":"石子合并 这道题与贪心中的合并不同的地方在于此时的合并只能合并相邻的石子堆，但是在贪心问题中可以合并任意堆。 思路： 状态表示：本题用二维数组f[i][j]来表示区间[i,j]全部合并完成的方案，f[i][j]的值用来表示花费的最小值。 状态计算：可发现，对任意区间，最后一次合并都是将两堆合成一堆的过程，那么我们划分时可以从[i,j]区间不同的划分方式入手。 f[i][j]=min(f[i][k]+f[k+1][j]+s[j]-s[i-1])//这里的s[]表示的是前缀和，因为最后一次合并得到需要耗费整个区间和的体力。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int f[400][400],a[400],s[400]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) s[i] = s[i-1]+a[i]; for(int len=2;len&lt;=n;len++) { for(int i=1;i+len-1&lt;=n;i++) { int l=i,r=i+len-1; f[l][r]=1e9;//这里因为求的是最小值，所以要将它初始化为尽可能大的值 for(int k=l;k&lt;=r-1;k++) { f[l][r]=min(f[l][k]+f[k+1][r]+s[r]-s[l-1],f[l][r]); } } } cout&lt;&lt;f[1][n]; } ","tags":[],"title":"区间dp","feature":"","link":"https://s111z.github.io/post/qu-jian-dp/","stats":{"text":"2 min read","time":95000,"words":347,"minutes":2},"date":"2023-09-18 12:05:42","dateFormat":"2023-09-18"},{"content":"动态规划的时间复杂度计算：状态 * 转移（指计算每个状态需要的计算量） 动态规划这类题还是按照状态表示和状态计算这个思路来考虑。 数字三角形 数字构成等腰三角形，从顶端开始，每次可以往左下走或者右下走，问走到底端时，路径上数字和的最大值是多少。 题目：数字三角形 求解 我们先考虑状态表示，这里用一个二维数组f[i][j]来表示所有从顶端走到(i,j)的路径和的集合，f[i][j]的值表示集合中的最大值。再考虑状态计算，我们看(i,j)前一个状态，从左上或者右上走到(i,j),所以就是max(f[i-1][j-1],f[i-1][j])+a[i][j],这样就可以计算出f[i][j]。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int a[600][600],f[600][600]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) scanf(&quot;%d&quot;,&amp;a[i][j]); //可能有负值，所以要将f[][]初始为-1e9 for(int i=1;i&lt;=n;i++)//这里从1开始是因为，f[1][2]会在更新f[2][2]时用到，所以不能因为f[1][1]要赋值就不更新 for(int j=0;j&lt;=i+1;j++)//因为更新右边缘时会用到上一层的数据，而且是右上方的，所以更新时要多更新一个 f[i][j]=-1e9; f[1][1]=a[1][1]; for(int i=2;i&lt;=n;i++) { for(int j=1;j&lt;=i;j++) { f[i][j]=max(f[i-1][j-1],f[i-1][j])+a[i][j]; } } int mx=-1e9; for(int i=1;i&lt;=n;i++) mx=max(mx,f[n][i]); cout&lt;&lt;mx; } 最长上升子序列 最长上升子序列 这道题也先从状态表示进行分析，用f[i]来表示以i结尾的字符串上升子序列的集合，然后f[i]的值表示最大值。关于状态计算，就要考虑如何划分，这道题的划分方法是按照倒数第二个字符是第几个来划分的。f[i]=max(f[k])+1;k&lt;i&amp;&amp;a[k]&lt;a[i] 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int a[1010],f[1010]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) { f[i]=1; for(int j=1;j&lt;i;j++) { if(a[j]&lt;a[i]) f[i] =max(f[i],f[j]+1); } } int mx=0; for(int i=1;i&lt;=n;i++) mx=max(mx,f[i]);//不一定是以最后一个数结尾 cout&lt;&lt;mx; } 求路径 这个就是在求上面的最大值的基础上记录一下每个状态是怎么更新得到的，然后倒着推即可 #include&lt;bits/stdc++.h&gt; using namespace std; int a[1010],f[1010],g[1010]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); for(int i=1;i&lt;=n;i++) { f[i]=1; for(int j=1;j&lt;i;j++) { if(a[j]&lt;a[i]) if(f[i]&lt;f[j]+1) { f[i] =max(f[i],f[j]+1); g[i]=j; } } } int mx=0,c=0; for(int i=1;i&lt;=n;i++) { if(mx&lt;f[i]) c=i; mx=max(mx,f[i]);//不一定是以最后一个数结尾 } cout&lt;&lt;mx&lt;&lt;endl; while(c) { printf(&quot;%d &quot;,c); c=g[c]; }//这里是从后往前输出，要想从前往后输出可再定义一个数组来装这些数，然后倒序输出即可。 } 但是数据规模一旦变大就不能再按照倒数第二个数位置来进行划分，不然一定会超时。考虑新的思路 例如:1,3,4，2，5，8;我们先枚举长度为1的上升子序列，比如1，3，再来看长度为2的上升子序列，直接考虑8，8可以接在3的后面，就一定可以接在1的后面，所以3就没有存在的必要，因为8接在1后面可以包含的范围更广，以此类推，对于所有不同长度的上升子序列，每种长度我们只需要存结尾数最小的即可，当第i个数要放入时，为了满足我们存的条件，我们要找出结尾比第i个数小的最大数，这样可以保证即使第i个数被存入后，也不会违背我们存数的原则，这里的查找利用二分来实现。然后更新q[r+1]即可。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; int a[100010],q[100010]; int main() { int n; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); q[0]=-2e9; int len=0;//表示最长子序列的长度 for(int i=1;i&lt;=n;i++) { int l=0,r=len;//对长度进行二分，q[k]存的是长度为k的上升子序列中最后一位最小的数，找出最大的小于a[i]的数，将a[i]接在它后面 while(l&lt;r) { int mid=(l+r+1)/2; if(q[mid]&lt;a[i]) l=mid; else r=mid-1; } len = max(len,r+1);//判断加上a[i]后需不需要更新最大长度 q[r+1]=a[i];//a[i]&lt;q[r+1],所以a[i]被接入后，q[r+1]就要被更新 } cout&lt;&lt;len; } 最长公共子序列 最长公共子序列 这类题就是给定两个长度已知的字符串，要求它们的最长公共子序列的长度。 状态表示，因为涉及到两个字符串，那么我们就用一个二维数组f[i][j]来表示s1以第i个字符结尾，s2以第j个字符结尾，它们公共子序列的集合，然后f[i][j]的值表示公共子序列长度的最大值。 状态计算：其实应该分成四类,00,01,10,11(第一个数表示a[i]选与不选，第二个数表示b[j]选与不选)，00:f[i-1][j-1];11:f[i-1][j-1]+1;这两个比较好表示，但我们以此类推表示出01:f[i-1][j],10:f[i][j-1]就不能精确表示i,j被选择了，但是注意到i，j被选择是包含在其中的，反正我们求的是最大值，所以是可以用这个来表示的，最大值可以重，只要不漏就好，同时f[i-1][j-1]也是包含在这两种情况中的，所以我们实际上只用三个状态来更新就好。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; char a[1010],b[1010]; int f[1010][1010]; int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); scanf(&quot;%s%s&quot;,a+1,b+1);//这里可以让第一个字符的下标为1 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) f[i][j]=max(f[i][j],f[i-1][j-1]+1);//相同字符不一定是对齐的,所以未必同时选会是最大的 } } cout&lt;&lt;f[n][m]; } 最短编辑距离 给定a,b两个字符串，可以对a进行增删改三种操作，使a最终等于b，问最短编辑距离是多少。 还是先考虑状态表示，因为有两个字符串，所以我们定义一个二维的数组f[i][j]来表示，a的前i个字符与b的前j个字符匹配需要的操作数。 然后考虑状态的划分，我们看最后一步操作，有四种操作：1.什么都不干，那么就是说a的前i-1个字符已经与b的前j-1个字符匹配完成同时a[i]b[j];2.增加一个字符，那就说明a的前i个字符已经与b的前j-1个字符 匹配完成，需要在a[i]后面补一个b[j]；3.删除一个字符，那就说明a的前i-1个字符已经与b的前j个字符匹配完成，把a[i]删掉即可；4.改，那就说明a的前i-1个字符与b的前j-1个字符已经匹配完成但是a[i]!=b[j],更改a[i]即可。对了还要考虑下边界情况，i0或者j==0时，可知f[0][j]和f[i][0]是非0的，所以要进行初始化。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; char a[1010],b[1010]; int f[1010][1010]; int main() { int n,m; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,a+1); scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%s&quot;,b+1); for(int i=0;i&lt;=m;i++) f[0][i]=i;//a的前0个字母要想跟b的前i个字母匹配就只能增 for(int i=0;i&lt;=n;i++) f[i][0]=i;//a的前i个字母要想跟b的前0个字母匹配就只能减 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1); } } printf(&quot;%d&quot;,f[n][m]); } 编辑距离 这类题其实相当于多个编辑最短距离问题的复合，给定n个字符串，然后给定m个询问，每个询问给一个字符串和一个限定数，问n个字符串中有多少个可以在操作数不超过限定数的情况下变换得到给定字符串（可以执行的操作仍然是增删改）。 思路：就全部录入n个字符串，写一个函数，返回每个给定的字符串与每次询问的字符串的最小编辑数，判断是否小于限定。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; char a[1010],b[1010]; int f[1010][1010]; int main() { int n,m; scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,a+1); scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%s&quot;,b+1); for(int i=0;i&lt;=m;i++) f[0][i]=i;//a的前0个字母要想跟b的前i个字母匹配就只能增 for(int i=0;i&lt;=n;i++) f[i][0]=i;//a的前i个字母要想跟b的前0个字母匹配就只能减 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) { f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1); if(a[i]==b[j]) f[i][j]=min(f[i][j],f[i-1][j-1]); else f[i][j]=min(f[i][j],f[i-1][j-1]+1); } } printf(&quot;%d&quot;,f[n][m]); } //int a[n],scanf(&quot;%s&quot;,a); 每个a[i]都有四位，可是一个字符仅一位，这么输入的话就是将字符填进每一位，然后将字符的二进制数拼接起来得到每个a[i] ","tags":[],"title":"线性dp","feature":"","link":"https://s111z.github.io/post/xian-xing-dp/","stats":{"text":"12 min read","time":712000,"words":2664,"minutes":12},"date":"2023-09-18 12:03:37","dateFormat":"2023-09-18"},{"content":"动态规划问题的关键一个是状态表示（集合的意义，集合中值的意义），一个是状态计算（如何划分进而用更小的集合算出目标集合，进而推出公式） 1.01背包问题（每件物品只有一个） 先进行状态表示，用f[i][j]来表示从前i个物品中进行选择同时体积不超过j，然后f[i][j]的值用来表示最大值。状态计算的关键就在于第i个物品选不选，如果不选，那就相当于从前i-1个中选，然后总体积不超过j，即f[i][j]=f[i-1][j]；如果选第i个，那么就f[i][j]=f[i-1][j-v[i]]+w[i],要给第i个物品留出位置。 //n是物品个数，m是背包体积，v[]表示每件物品体积，w[]表示每件物品的价值（权重） for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=m;j++) { f[i][j]=f[i-1][j];//f[i-1][j]是一定存在的 if(v[i]&lt;=j) f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]); //要保证第i个可以被放入 } } 优化：由递推式可以发现，第一维都是在i-1的基础上得到的，所以实际上更新时只使用到上一层的数据，那么我们可以将第一维去掉，i从小到大访问，所以对于每个f[j]存的一定是i-1时的值，那么f[i][j]=f[i-1][j]可以直接优化成f[j]=f[j],但是因为j-v[i]&lt;j，所以j如果从小到大访问的话，f[j-v[i]]就是i层的值，而非i-1层的值，故而j从大到小进行访问。这样小于等于j的值一定是i-1层的值。 for(int i=1;i&lt;=n;i++) { for(int j=m;j&gt;=v[i];j--)//这里直接把j的范围限制在一定可以放入第i个物品的范围内 { f[j]=max(f[j],f[j-v[i]]+w[i]); } } 2.完全背包问题（每件物品有无限多个） 也先找状态表示，f[i][j]表示从前i个物品中选同时体积不超过j，关于状态计算，这类问题的关键在于第i个物品选多少个，从0开始考虑，那么就得到 f[i][j]=max(f[i-1][j-k * v[i]]+k * w[i]) for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=m;j++) { f[i][j]=f[i-1][j];//第i个物品一个都不选 for(int k=1;k*v[i]&lt;=j;k++) { f[i][j]=max(f[i][j],f[i][j-k*v[i]]+w[i]*k); } } } 当然这样很容易超时，那么就要进行优化， f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,f[i-1][j-3v]+3w,...) f[i][j-v]=max( f[i-1][j-v], f[i-1][j-2v]+w ,f[i-1][j-3v]+2w,...) 由此，f[i][j]=max(f[i-1][j],f[i][j-v]+w); 所以f[i][j]的状态计算就被成功优化 for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;m;j++) { f[i][j]=f[i-1][j]; if(j&gt;=v[i]) f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]); } } 但是可发现这个二维的状态表示可以被优化为一维的状态表示。 对于f[j],每次更新前存的都是i-1层的值，那么f[i][j]=f[i-1][j]就可以用f[j]=f[j]代替，j-v[i]小于j,所以当访问到j时，已经被更新成第i层的值了,也即f[i][j]=f[i][j-v]+w可以用f[j]=f[j-v]+w来代替。 for(int i=1;i&lt;=n;i++) { for(int j=v[i];j&lt;=m;j++) { f[j]=max(f[j],f[j-v[i]]+w[i]); } } 3.多重背包问题(有些类似完全背包问题，但是多重背包问题中，每件物品的数量是有限制的。) 这类问题也是用f[i][j]来表示从前i个物品中选同时体积不超过j，关于状态计算在于第i个物品选多少个 朴素版做法 for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=m;j++) { f[i][j]=f[i-1][j];//一个都不选 for(int k=1;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++) { f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]); } } } 同样数据一大就一定会超时，所以一定要优化，但不能用优化完全背包问题的思路来进行优化 f[i][j]=max(f[i-1][j],f[i-1][j-v]+w,f[i-1][j-2v]+2w,...f[i-1][j-sv]+sw); f[i][j-v]=max( f[i-1][j-v] ,f[i-1][j-2v]+w,...f[i-1][j-sv]+(s-1)w,f[i-1][j-(s+1)v]+sw); 故而不能用优化完全背包问题的方法来进行优化，这里用到一种比较巧的方法来优化，二进制法。 1，2，4,8,... 1，2可以拼出1，2，3 1，2，4可以拼出1，2，3，4，5，6，7 ... 由此将s进行拆分打包，将每一包视为单独的个体，那就转化为01背包问题，每个个体选与不选，从0-s都可以被凑出来。 二维写法： int v[],w[],f[] int c=0; for(int i=1;i&lt;=n;i++) { int a,b,s; int k=1; while(k&lt;=s) { c++; v[c]=k*a; w[c]=k*b; s -= k; k *= 2; } } for(int i=1;i&lt;=c;i++) { for(int j=m;j&gt;=v[i];j--) { f[i][j]=f[i-1][j]; f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]); } } 一维优化： int v[],w[],f[] int c=0; for(int i=1;i&lt;=n;i++) { int a,b,s; int k=1; while(k&lt;=s) { c++; v[c]=k*a; w[c]=k*b; s -= k; k *= 2; } } for(int i=1;i&lt;=c;i++) { for(int j=m;j&gt;=v[i];j--) { f[j]=max(f[j],f[j-v[i]]+w[i]); } } 当然数据范围更大后二进制打包也会超时，就又要引入一种新的方法——滑动窗口优化。 滑动窗口优化的思路在于通过找规律可发现j只会从与j%v余数相同的更新而来，因为每次新增时，会减去j的整数倍来腾空间。而且找规律可发现，每组的更新可以抽象成滑动窗口问题，所以我们可以将j分组(按照余数分组，可证明一定可以将合法的j都讨论到），对于每一组，建一个单调队列来模拟滑动窗口。详细的证明可见：多重背包问题单调队列优化的证明 #include &lt;iostream&gt; using namespace std; const int N = 1010, M = 20010; int n, m; int v[N], w[N], s[N]; int f[N][M]; int q[M]; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i]; for (int i = 1; i &lt;= n; ++ i) { for (int r = 0; r &lt; v[i]; ++ r) { int hh = 0, tt = -1;//对每一个余数开一个队列，同队列中的可以进行更新 for (int j = r; j &lt;= m; j += v[i]) { while (hh &lt;= tt &amp;&amp; j - q[hh] &gt; s[i] * v[i]) hh ++ ;//差值大于s[i]*v[i]即表示窗口已满，因为最多加到sw //相当于讨论不同体积下放入物品的情况 while (hh &lt;= tt &amp;&amp; f[i - 1][q[tt]] + (j - q[tt]) / v[i] * w[i] &lt;= f[i - 1][j]) -- tt; //弹出后面不会再用到的元素，前面体积更小的如果价值小于当前情况的话，那么后面一定不会用前面价值小的进行更新 q[ ++ tt] = j;//将最大的元素放到顶端 f[i][j] = f[i - 1][q[hh]] + (j - q[hh]) / v[i] * w[i]; //最大的一定在队头位置，如果队头上面有更大的，那个更大的被放入时会将整个队列弹空 } } } cout &lt;&lt; f[n][m] &lt;&lt; endl; return 0; } 当然二维写法可以优化成一维，但要注意基于本题思路，j只能从小到大访问，所以更新后面时用到的可能就是被更新的i层的数据，所以要用一个数组来存i-1层的数据。 #include&lt;bits/stdc++.h&gt; using namespace std; int v[1010],w[1010],s[1010],q[20010],f[20010],g[20010]; int main() { int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) { scanf(&quot;%d%d%d&quot;,&amp;v[i],&amp;w[i],&amp;s[i]); } for(int i=1;i&lt;=n;i++) { memcpy(g,f,sizeof f); for(int r=0;r&lt;v[i];r++) { int hh=0,tt=-1; for(int j=r;j&lt;=m;j+=v[i]) { while(hh&lt;=tt&amp;&amp;j-q[hh]&gt;s[i]*v[i]) hh++; while(hh&lt;=tt&amp;&amp;g[q[tt]]+(j-q[tt])/v[i]*w[i]&lt;g[j]) tt--; q[++tt]=j; f[j]=g[q[hh]]+(j-q[hh])/v[i]*w[i]; } } } printf(&quot;%d&quot;,f[m]); } 4.分组背包问题（有i组，每组只能选一个） 这里用f[i][j]来表示从前i组中选同时体积不能超过j；关于状态计算就是从第i组选0个，或者第1个，第2个，... for(int i=1;i&lt;=n;i++) { for(int j=0;j&lt;=m;j++) { f[i][j]=f[i-1][j];//不从第i组中进行选择 for(int k=1;k&lt;=s[i];k++) { if(v[i][k]&lt;=j) f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]); } } } 一维优化 for(int i=1;i&lt;=n;i++) { for(int j=m;j&gt;=0;j--) { for(int k=1;k&lt;=s[i];k++) { if(v[i][k]&lt;=j) f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);//要用i-1层的数据 } } } 混合背包问题 有三类物品：第一类物品只能用一次，第二类物品可用无限多次，第三类物品最多只能用si次，然后给定背包容量，问不超过容量的最大价值。 思路：将第三类物品进行二进制划分得到一堆新的第一类物品，然后，开始遍历所有的物品，对于01背包问题就从大到小遍历体积m，对于完全背包问题就从小到大遍历体积m（理由见前面关于01背包和完全背包的推导）。 代码： struct th { int v,w,kind; }; vector&lt;th&gt;t; //s==-1,01背包，s==0完全背包，s&gt;0多重背包 cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) { int v,w,s; scanf(&quot;%d%d%d&quot;,&amp;v,&amp;w,&amp;s); if(s&lt;=0) t.push_back({v,w,s}); else { for(int k=1;k&lt;=s;k*=2) { s -= k; t.push_back({k*v,k*w,-1}); } if(s) t.push_back({s*v,s*w,-1}); } } for(auto it:t) { if(it.kind==-1) for(int j=m;j&gt;=it.v;j--) f[j]=max(f[j],f[j-it.v]+it.w); else for(int j=it.v;j&lt;=m;j++) f[j]=max(f[j],f[j-it.v]+it.w); } cout&lt;&lt;f[m]&lt;&lt;endl; 二维费用的背包问题 这类问题限定容量和重量（对01背包） 思路：既然限定有两个，那么就定义二维数组（定义三维数组的话，1e31e31e3内存会超，故定义二维数组）f[i][j]表示体积不超过i，重量不超过j时的最大值，写个三重循环，然后更新时同时更新i,j 代码： for(int i=1;i&lt;=N;i++) { //01背包问题，所以对两重限制的枚举都是从小到大，这道题朴素写法一定会超时 for(int j=V;j&gt;=v[i];j--) { for(int k=M;k&gt;=m[i];k--) { f[j][k]=max(f[j][k],f[j-v[i]][k-m[i]]+w[i]);//在更新状态时，两重限定都要更新 } } } 背包问题求方案数 这类问题就是求最优解的方案数（对01背包） 除f[]数组外，再开一个数组记录方案数，对于更新时定义两个变量t,s,t=max(f[j],f[j-v[i]]+w[i]),如果tf[j]那么 s += g[j],如果tf[j-v[i]]+w[i],那么s += g[j-v[i]],最后再更新f[j]和g[j]。 代码： for(int i=1;i&lt;=n;i++) { for(int j=m;j&gt;=v[i];j--) { int t=max(f[j],f[j-v[i]]+w[i]); int s=0; if(t==f[j]) s += g[j],s%=mod; if(t==f[j-v[i]]+w[i]) s += g[j-v[i]],s %= mod; f[j]=t; g[j]=s; } } int mx=0; for(int i=0;i&lt;=m;i++) mx=max(f[i],mx); int res=0; for(int i=0;i&lt;=m;i++) { if(f[i]==mx) { res += g[i]; res %= mod; } } 求背包问题的方案 这类题就是求具体某一种最优方案，下面讨论的是求字典序最小的方案 这类题比较独特的一点是对于i的访问是倒序的，所以最优解是f[1][j],那么我们考虑方案时正序访问i，f[1][j]=max(f[2][j],f[2][j-v[1]]+w[1]),如果f[1][j]==f[2][j]那么证明最优方案中不包含1，如果f[1][j]==f[2][j-v[1]]+w[1],那么1就可以被放入，当两个都可以的时候为了得到最小字典序，1也是可以被放入的。 代码： for(int i=n;i&gt;=1;i--) { for(int j=0;j&lt;=m;j++) { f[i][j]=f[i+1][j]; if(v[i]&lt;=j) f[i][j]=max(f[i][j],f[i+1][j-v[i]]+w[i]); } } int vol=m; for(int i=1;i&lt;=n;i++) { //因为i是倒序遍历的，所以f[1][m]是最优解，那我们正序去看，如果f[1][m]==f[2][vol-v[1]]+w[1]证明1可以被放入，哪怕f[1][m]==f[2][m],也会为了字典序将1放入，以此类推。 if(vol&gt;=v[i]&amp;&amp;f[i][vol]==f[i+1][vol-v[i]]+w[i]) //这里要判断一下，首先第i个物品要能放进去。因为f[][]已经被从后往前更新过了，如果后一个判断条件成立，就证明i是方案中的 { printf(&quot;%d &quot;,i); vol -= v[i]; } } 有依赖的背包问题 ","tags":[],"title":"背包问题","feature":"","link":"https://s111z.github.io/post/bei-bao-wen-ti/","stats":{"text":"17 min read","time":965000,"words":3442,"minutes":17},"date":"2023-09-18 12:03:14","dateFormat":"2023-09-18"},{"content":"1.排序不等式 排队打水 本题要求所有人等待和的最小值，为得到最优解就要将打水慢的放在后面。所以只用排序后再遍历计数即可。 可以用不等式的方法证明贪心思路的正确性。 2.绝对值不等式 货仓选址 本题实际上是求绝对值和的最小值， ","tags":[],"title":"其他贪心问题","feature":"","link":"https://s111z.github.io/post/qi-ta-tan-xin-wen-ti/","stats":{"text":"1 min read","time":20000,"words":100,"minutes":1},"date":"2023-09-18 12:02:51","dateFormat":"2023-09-18"},{"content":"1.区间选点&amp;最大不相交区间数量 这两类问题虽然一个求最大一个求最小，但实际上，思路一致。 区间选点即选尽量少的点，使之落在尽可能多的区间内，先按照右端点进行从小到大的排序，选右端点，只要下一个区间包含这个点，那么就不用再选新的点，直到访问到不包含这个点的区间，然后要选一个新的点。（这里有个变化就是开区间和闭区间，涉及边界的处理。） -最大不相交区间的数量，也是先按照右端点进行排序，然后然后进行访问，找到不包含右端点的区间就更新答案。 2.区间分组 给定一些区间，将这些区间进行分类，使组内的区间没有交集。这个要按照左端点进行排序，然后记录每组的最右端点，需要用到一个小根堆，将每组的最右端点放入，针对每次访问到的区间，先将该区间的左端点与已分好组的最小的最右端点进行比较，如果小于等于这个的最小端点那么一定不可以放入，任何一个已经分好的区间（证明如下），就必须单独为它开一个新组，否则就可以将它放入已经分好的区间，如果可以放入多组中随便挑一组就好，这里我们将它放入第一组，再更新第一组的最右端点。 证明：这里的特殊情况就是，这段区间的左端点在第一组中，但是右端点在第二组的最左端点前面，这种情况是不成立的，因为这两组既然被分成两组就证明两组是相交的，而且我们先按照左端点进行了排序，所以这个左端点一定在第二组左端点的后面，但同时又在第一组右端点的左边，那么一定与这两个区间相交，所以我们需要新开一个区间。 区间覆盖 这类题就是先给一个大区间，然后给一些小区间，问最少选几个区间可以将大区间覆盖，如果不能将大区间覆盖就输出-1 解法：选择一个小区间时，如果有多个区间可以包含大区间的左端点，那么就挑右端点最靠后的，因为我们要选的是最小数量，然后沿用这个思路，每次挑完后将大区间的st更新为所选小区间的右端点。 Huffan树 这种题就是合并问题，好几堆东西，合并时消耗的体力是两堆的和，问最少消耗的体力。 解法就是，将所有的数放入小根堆，每次合并最小的两个。 ","tags":[],"title":"区间贪心","feature":"","link":"https://s111z.github.io/post/qu-jian-tan-xin/","stats":{"text":"3 min read","time":149000,"words":744,"minutes":3},"date":"2023-09-18 12:02:18","dateFormat":"2023-09-18"},{"content":"对于要求找最大最小你值，以及待求变量具有单调性的题目都可以用二分来写 int judge(int x) {} int main() { ... int l=下界,r=上界,ans while(l&lt;=r) { int mid=(l+r)/2; if(judge(mid) { //l或r更新 ans=mid; } else //l或r更新 } ... } 题目 一元三次方程求解 思路：根与根的绝对值大于等于1，所以在长度为1的区间里最多只有一个根，那么就可以在每个长度为1的区间内进行二分 代码 #include&lt;bits/stdc++.h&gt; using namespace std; double a,b,c,d; double check(double x) { return a*x*x*x*1.0+b*x*x*1.0+c*x*1.0+d; } int main() { scanf(&quot;%lf%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c,&amp;d); int k=0; for(int i=-100;i&lt;100;i++) { double l=i,r=i+1; if(check(l)==0)//因为下一个i的时候会去检查当前的r { printf(&quot;%.2lf &quot;,l); k++; } if(check(l)*check(r)&lt;0) { while(r-l&gt;=0.001) { double mid=(l+r)/2; if(check(mid)*check(r)&lt;=0) l=mid; else r=mid; } printf(&quot;%.2lf &quot;,r); k++; } if(k==3) break; } return 0; } ps:这道题涉及到对浮点数的二分，最后输出r，若输出mid则精度可能不够 跳石头 思路：这道题要求的是移走m块石头后，最小距离最大是多少。这个最小距离的最大值是单调的，故而可以使用二分来写。另外题目保证一定有答案，故而最后不用对答案进行验证。而且因为要求的是最大的值，所以当一个值可以后要考虑更大的行不行，这样l,r更新的方式也找到了。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int d,n,m; int a[50010]; int check(int x) { int i=0,now=0,t=0; while(i&lt;=n) { i++; if(a[i]-a[now]&lt;x) t++;//小于最小距离，所以要移开 else now=i; } if(t&lt;=m) return 1;//距离要缩小 else return 0; } int main() { scanf(&quot;%d%d%d&quot;,&amp;d,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); a[n+1]=d; int l=1,r=d,ans; while(l&lt;=r) { int mid=(l+r)/2; if(check(mid)) { ans=mid; l=mid+1; } else r=mid-1; } printf(&quot;%d&quot;,ans); } 刺杀大使 思路：这道题求的是最大伤害的最小值，那么其实我们也可以进行二分，这个题的难点其实在check函数，我们可以参考bfs的写法，反正有四个方向，如果该位置的伤害大于我们此时的伤害，那么这个点就无法到达，最后如果可以到第n行那么就返回1，否则返回0；另外l,r更新的时候也要注意，如果为1，就要考虑是否可以更小，否则就考虑是否可以更大。这道题也是保证有答案，所以最终不需要再次验证。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; int a[1010][1010]; int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0}; int n,m; int st[1010][1010]; int check(int sx) { memset(st,0,sizeof st); queue&lt;pair&lt;int,int&gt;&gt;q; q.push({1,1}); st[1][1]=1; while(q.size()) { auto t=q.front(); q.pop(); int x=t.first,y=t.second; for(int i=0;i&lt;4;i++) { int nx=x+dx[i],ny=y+dy[i]; if(1&lt;=nx&amp;&amp;nx&lt;=n&amp;&amp;1&lt;=ny&amp;&amp;ny&lt;=m&amp;&amp;!st[nx][ny]&amp;&amp;a[nx][ny]&lt;=sx) { st[nx][ny]=1; if(nx==n) return 1; q.push({nx,ny}); } } } return 0; } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); int mx=0,mi=1000; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) { scanf(&quot;%d&quot;,&amp;a[i][j]); mi=min(mi,a[i][j]); mx=max(mx,a[i][j]); } int l=mi,r=mx,ans; while(l&lt;=r) { int mid=(l+r)/2; if(check(mid)) { ans=mid; r=mid-1; } else l=mid+1; } printf(&quot;%d&quot;,ans); } 聪明的质检员 思路：对于这道题，要求的是|s-y|的最小值，显然不能对这个值进行二分，但是题目又说通过调整w的值，可发现w变大,y变小，w变小，y变大，也就可以二分w来实现。另外还有一个难点在于，有很多个操作区间，为了需要用到前缀和来优化。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int n,m,s,sum; int w[200010],v[200010],l[200010],r[200010]; int sn[200010],sv[200010]; int check(int x) { memset(sn,0,sizeof sn); memset(sv,0,sizeof sv); for(int i=1;i&lt;=n;i++) { if(w[i]&gt;=x) sn[i]=sn[i-1]+1,sv[i]=sv[i-1]+v[i]; else sn[i]=sn[i-1],sv[i]=sv[i-1]; } int y=0; for(int i=1;i&lt;=m;i++) { y += (sn[r[i]]-sn[l[i]-1])*(sv[r[i]]-sv[l[i]-1]); } sum=abs(y-s); if(y&lt;=s) return true; else return false; } signed main() { scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;s); int mi=1000010,mx=0; for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld%lld&quot;,&amp;w[i],&amp;v[i]); mx=max(mx,w[i]); mi=min(mi,w[i]); } for(int i=1;i&lt;=m;i++) scanf(&quot;%lld%lld&quot;,&amp;l[i],&amp;r[i]); int l=mi,r=mx,ans=0x3f3f3f3f3f3f3f3f; while(l&lt;=r) { int mid=(l+r)/2; if(check(mid)) r=mid-1;//w变小，y变大 else l=mid+1; ans = min(sum,ans); } printf(&quot;%lld&quot;,ans); } 借教室 思路：本题的订单按顺序执行，要查找需要修改哪个订单，按照题意只需要修改一个订单，那么只要二分是1-哪个订单时无法成立即可，这里需要计算每天有多少个教室被借出，故而用差分和前缀和来处理，要注意会不会爆int 代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int n,m; int d[1000010],s[1000010],t[1000010],a[1000010]; int room[1000010],sr[1000010]; int check(int mid) { memset(room,0,sizeof room); memset(sr,0,sizeof sr); for(int i=1;i&lt;=mid;i++) { room[s[i]] += d[i]; room[t[i]+1] -= d[i]; } for(int i=1;i&lt;=n;i++) { sr[i]=sr[i-1]+room[i]; if(sr[i]&gt;a[i]) return false; } return true; } signed main() { scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf(&quot;%lld%lld%lld&quot;,&amp;d[i],&amp;s[i],&amp;t[i]); int l=0,r=m,ans=0; while(l&lt;=r) { int mid=(l+r)/2; if(check(mid)) { l=mid+1; } else { ans=mid; r=mid-1; } } if(ans) printf(&quot;-1\\n&quot;); printf(&quot;%lld&quot;,ans); } 自动刷题机 思路：本题要求一个最大值，要求一个最小值，所以要进行两次二分，每次二分的判断条件不同，且更新方式不同，另外本题还涉及不存在的情况，所以要判断二分出的结果是否符合要求。 代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long int n,k; int a[100010]; bool check1(int mid) { int c=0,res=0; for(int i=1;i&lt;=n;i++) { c += a[i]; if(c&gt;=mid) { res++; c=0; } if(c&lt;0) c=0; } if(res &lt;= k)return true; else return false; } bool check2(int mid) { int c=0,res=0; for(int i=1;i&lt;=n;i++) { c += a[i]; if(c&gt;=mid) { res++; c=0; } if(c&lt;0) c=0; } if(res &gt;= k)return true; else return false; } bool check3(int mid) { int c=0,res=0; for(int i=1;i&lt;=n;i++) { c += a[i]; if(c&gt;=mid) { res++; c=0; } if(c&lt;0) c=0; } if(res == k)return true; else return false; } signed main() { scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); int sum=0; for(int i=1;i&lt;=n;i++) { scanf(&quot;%lld&quot;,&amp;a[i]); if(a[i]&gt;0) sum += a[i]; } int l=1,r=sum,mi=sum,mx=0; while(l&lt;=r)//最小值 { int mid=(l+r)/2; if(check1(mid)) { r=mid-1; mi=min(mi,mid); } else l=mid+1; } l=1,r=sum; while(l&lt;=r) { int mid=(l+r)/2; if(check2(mid)) { l=mid+1; mx=max(mx,mid); } else r=mid-1; } if(check3(mi)&amp;&amp;check3(mx)) printf(&quot;%lld %lld&quot;,mi,mx); else printf(&quot;-1&quot;); } ","tags":[],"title":"二分","feature":"","link":"https://s111z.github.io/post/er-fen/","stats":{"text":"10 min read","time":585000,"words":1899,"minutes":10},"date":"2023-09-18 11:59:39","dateFormat":"2023-09-18"},{"content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","tags":[{"name":"Gridea","slug":"azrwOAxfs","used":true,"link":"https://s111z.github.io/tag/azrwOAxfs/"}],"title":"Hello Gridea","feature":"https://s111z.github.io/post-images/hello-gridea.png","link":"https://s111z.github.io/post/hello-gridea/","stats":{"text":"2 min read","time":62000,"words":298,"minutes":2},"date":"2018-12-12 00:00:00","dateFormat":"2018-12-12"}]}
